(self.webpackChunk_open_sauced_insights=self.webpackChunk_open_sauced_insights||[]).push([[4753],{"./node_modules/@octokit/auth-app/dist-node/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";var mod,console=__webpack_require__("./node_modules/console-browserify/index.js"),__create=Object.create,__defProp=Object.defineProperty,__getOwnPropDesc=Object.getOwnPropertyDescriptor,__getOwnPropNames=Object.getOwnPropertyNames,__getProtoOf=Object.getPrototypeOf,__hasOwnProp=Object.prototype.hasOwnProperty,__copyProps=(to,from,except,desc)=>{if(from&&"object"==typeof from||"function"==typeof from)for(let key of __getOwnPropNames(from))__hasOwnProp.call(to,key)||key===except||__defProp(to,key,{get:()=>from[key],enumerable:!(desc=__getOwnPropDesc(from,key))||desc.enumerable});return to},dist_src_exports={};((target,all)=>{for(var name in all)__defProp(target,name,{get:all[name],enumerable:!0})})(dist_src_exports,{createAppAuth:()=>createAppAuth,createOAuthUserAuth:()=>import_auth_oauth_user2.createOAuthUserAuth}),module.exports=(mod=dist_src_exports,__copyProps(__defProp({},"__esModule",{value:!0}),mod));var import_universal_user_agent=__webpack_require__("./node_modules/universal-user-agent/dist-web/index.js"),import_request=__webpack_require__("./node_modules/@octokit/request/dist-web/index.js"),import_auth_oauth_app=__webpack_require__("./node_modules/@octokit/auth-oauth-app/dist-web/index.js"),import_deprecation=__webpack_require__("./node_modules/deprecation/dist-web/index.js"),import_universal_github_app_jwt=(((mod,isNodeMode,target)=>{target=null!=mod?__create(__getProtoOf(mod)):{},__copyProps(!isNodeMode&&mod&&mod.__esModule?target:__defProp(target,"default",{value:mod,enumerable:!0}),mod)})(__webpack_require__("./node_modules/@octokit/auth-oauth-app/dist-web/index.js")),__webpack_require__("./node_modules/universal-github-app-jwt/dist-web/index.bundled.js"));async function getAppAuthentication({appId,privateKey,timeDifference}){try{const appAuthentication=await(0,import_universal_github_app_jwt.githubAppJwt)({id:+appId,privateKey,now:timeDifference&&Math.floor(Date.now()/1e3)+timeDifference});return{type:"app",token:appAuthentication.token,appId:appAuthentication.appId,expiresAt:new Date(1e3*appAuthentication.expiration).toISOString()}}catch(error){throw"-----BEGIN RSA PRIVATE KEY-----"===privateKey?new Error("The 'privateKey` option contains only the first line '-----BEGIN RSA PRIVATE KEY-----'. If you are setting it using a `.env` file, make sure it is set on a single line with newlines replaced by '\n'"):error}}var import_lru_cache=__webpack_require__("./node_modules/@octokit/auth-app/node_modules/lru-cache/dist/commonjs/index.js");function optionsToCacheKey({installationId,permissions={},repositoryIds=[],repositoryNames=[]}){const permissionsString=Object.keys(permissions).sort().map((name=>"read"===permissions[name]?name:`${name}!`)).join(",");return[installationId,repositoryIds.sort().join(","),repositoryNames.join(","),permissionsString].filter(Boolean).join("|")}function toTokenAuthentication({installationId,token,createdAt,expiresAt,repositorySelection,permissions,repositoryIds,repositoryNames,singleFileName}){return Object.assign({type:"token",tokenType:"installation",token,installationId,permissions,createdAt,expiresAt,repositorySelection},repositoryIds?{repositoryIds}:null,repositoryNames?{repositoryNames}:null,singleFileName?{singleFileName}:null)}async function getInstallationAuthentication(state,options,customRequest){const installationId=Number(options.installationId||state.installationId);if(!installationId)throw new Error("[@octokit/auth-app] installationId option is required for installation authentication.");if(options.factory){const{type,factory,oauthApp,...factoryAuthOptions}={...state,...options};return factory(factoryAuthOptions)}const optionsWithInstallationTokenFromState=Object.assign({installationId},options);if(!options.refresh){const result=await async function get(cache,options){const cacheKey=optionsToCacheKey(options),result=await cache.get(cacheKey);if(!result)return;const[token,createdAt,expiresAt,repositorySelection,permissionsString,singleFileName]=result.split("|");return{token,createdAt,expiresAt,permissions:options.permissions||permissionsString.split(/,/).reduce(((permissions2,string)=>(/!$/.test(string)?permissions2[string.slice(0,-1)]="write":permissions2[string]="read",permissions2)),{}),repositoryIds:options.repositoryIds,repositoryNames:options.repositoryNames,singleFileName,repositorySelection}}(state.cache,optionsWithInstallationTokenFromState);if(result){const{token:token2,createdAt:createdAt2,expiresAt:expiresAt2,permissions:permissions2,repositoryIds:repositoryIds2,repositoryNames:repositoryNames2,singleFileName:singleFileName2,repositorySelection:repositorySelection2}=result;return toTokenAuthentication({installationId,token:token2,createdAt:createdAt2,expiresAt:expiresAt2,permissions:permissions2,repositorySelection:repositorySelection2,repositoryIds:repositoryIds2,repositoryNames:repositoryNames2,singleFileName:singleFileName2})}}const appAuthentication=await getAppAuthentication(state),request=customRequest||state.request,{data:{token,expires_at:expiresAt,repositories,permissions:permissionsOptional,repository_selection:repositorySelectionOptional,single_file:singleFileName}}=await request("POST /app/installations/{installation_id}/access_tokens",{installation_id:installationId,repository_ids:options.repositoryIds,repositories:options.repositoryNames,permissions:options.permissions,mediaType:{previews:["machine-man"]},headers:{authorization:`bearer ${appAuthentication.token}`}}),permissions=permissionsOptional||{},repositorySelection=repositorySelectionOptional||"all",repositoryIds=repositories?repositories.map((r=>r.id)):void 0,repositoryNames=repositories?repositories.map((repo=>repo.name)):void 0,createdAt=(new Date).toISOString();return await async function set(cache,options,data){const key=optionsToCacheKey(options),permissionsString=options.permissions?"":Object.keys(data.permissions).map((name=>`${name}${"write"===data.permissions[name]?"!":""}`)).join(","),value=[data.token,data.createdAt,data.expiresAt,data.repositorySelection,permissionsString,data.singleFileName].join("|");await cache.set(key,value)}(state.cache,optionsWithInstallationTokenFromState,{token,createdAt,expiresAt,repositorySelection,permissions,repositoryIds,repositoryNames,singleFileName}),toTokenAuthentication({installationId,token,createdAt,expiresAt,repositorySelection,permissions,repositoryIds,repositoryNames,singleFileName})}async function auth(state,authOptions){switch(authOptions.type){case"app":return getAppAuthentication(state);case"oauth":state.log.warn(new import_deprecation.Deprecation('[@octokit/auth-app] {type: "oauth"} is deprecated. Use {type: "oauth-app"} instead'));case"oauth-app":return state.oauthApp({type:"oauth-app"});case"installation":return getInstallationAuthentication(state,{...authOptions,type:"installation"});case"oauth-user":return state.oauthApp(authOptions);default:throw new Error(`Invalid auth type: ${authOptions.type}`)}}var import_auth_oauth_user=__webpack_require__("./node_modules/@octokit/auth-oauth-user/dist-web/index.js");__webpack_require__("./node_modules/@octokit/request-error/dist-web/index.js");var REGEX=function routeMatcher(paths){const regex=`^(?:${paths.map((p=>p.split("/").map((c=>c.startsWith("{")?"(?:.+?)":c)).join("/"))).map((r=>`(?:${r})`)).join("|")})$`;return new RegExp(regex,"i")}(["/app","/app/hook/config","/app/hook/deliveries","/app/hook/deliveries/{delivery_id}","/app/hook/deliveries/{delivery_id}/attempts","/app/installations","/app/installations/{installation_id}","/app/installations/{installation_id}/access_tokens","/app/installations/{installation_id}/suspended","/marketplace_listing/accounts/{account_id}","/marketplace_listing/plan","/marketplace_listing/plans","/marketplace_listing/plans/{plan_id}/accounts","/marketplace_listing/stubbed/accounts/{account_id}","/marketplace_listing/stubbed/plan","/marketplace_listing/stubbed/plans","/marketplace_listing/stubbed/plans/{plan_id}/accounts","/orgs/{org}/installation","/repos/{owner}/{repo}/installation","/users/{username}/installation"]);var FIVE_SECONDS_IN_MS=5e3;async function hook(state,request,route,parameters){const endpoint=request.endpoint.merge(route,parameters),url=endpoint.url;if(/\/login\/oauth\/access_token$/.test(url))return request(endpoint);if(function requiresAppAuth(url){return!!url&&REGEX.test(url.split("?")[0])}(url.replace(request.endpoint.DEFAULTS.baseUrl,""))){const{token:token2}=await getAppAuthentication(state);let response;endpoint.headers.authorization=`bearer ${token2}`;try{response=await request(endpoint)}catch(error){if(function isNotTimeSkewError(error){return!(error.message.match(/'Expiration time' claim \('exp'\) must be a numeric value representing the future time at which the assertion expires/)||error.message.match(/'Issued at' claim \('iat'\) must be an Integer representing the time that the assertion was issued/))}(error))throw error;if(void 0===error.response.headers.date)throw error;const diff=Math.floor((Date.parse(error.response.headers.date)-Date.parse((new Date).toString()))/1e3);state.log.warn(error.message),state.log.warn(`[@octokit/auth-app] GitHub API time and system time are different by ${diff} seconds. Retrying request with the difference accounted for.`);const{token:token3}=await getAppAuthentication({...state,timeDifference:diff});return endpoint.headers.authorization=`bearer ${token3}`,request(endpoint)}return response}if((0,import_auth_oauth_user.requiresBasicAuth)(url)){const authentication=await state.oauthApp({type:"oauth-app"});return endpoint.headers.authorization=authentication.headers.authorization,request(endpoint)}const{token,createdAt}=await getInstallationAuthentication(state,{},request);return endpoint.headers.authorization=`token ${token}`,sendRequestWithRetries(state,request,endpoint,createdAt)}async function sendRequestWithRetries(state,request,options,createdAt,retries=0){const timeSinceTokenCreationInMs=+new Date-+new Date(createdAt);try{return await request(options)}catch(error){if(401!==error.status)throw error;if(timeSinceTokenCreationInMs>=FIVE_SECONDS_IN_MS)throw retries>0&&(error.message=`After ${retries} retries within ${timeSinceTokenCreationInMs/1e3}s of creating the installation access token, the response remains 401. At this point, the cause may be an authentication problem or a system outage. Please check https://www.githubstatus.com for status information`),error;const awaitTime=1e3*++retries;return state.log.warn(`[@octokit/auth-app] Retrying after 401 response to account for token replication delay (retry: ${retries}, wait: ${awaitTime/1e3}s)`),await new Promise((resolve=>setTimeout(resolve,awaitTime))),sendRequestWithRetries(state,request,options,createdAt,retries)}}var VERSION="6.0.1",import_auth_oauth_user2=__webpack_require__("./node_modules/@octokit/auth-oauth-user/dist-web/index.js");function createAppAuth(options){if(!options.appId)throw new Error("[@octokit/auth-app] appId option is required");if(!Number.isFinite(+options.appId))throw new Error("[@octokit/auth-app] appId option must be a number or numeric string");if(!options.privateKey)throw new Error("[@octokit/auth-app] privateKey option is required");if("installationId"in options&&!options.installationId)throw new Error("[@octokit/auth-app] installationId is set to a falsy value");const log=Object.assign({warn:console.warn.bind(console)},options.log),request=options.request||import_request.request.defaults({headers:{"user-agent":`octokit-auth-app.js/${VERSION} ${(0,import_universal_user_agent.getUserAgent)()}`}}),state=Object.assign({request,cache:new import_lru_cache.LRUCache({max:15e3,ttl:354e4})},options,options.installationId?{installationId:Number(options.installationId)}:{},{log,oauthApp:(0,import_auth_oauth_app.createOAuthAppAuth)({clientType:"github-app",clientId:options.clientId||"",clientSecret:options.clientSecret||"",request})});return Object.assign(auth.bind(null,state),{hook:hook.bind(null,state)})}},"./node_modules/@octokit/auth-app/node_modules/lru-cache/dist/commonjs/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";var process=__webpack_require__("./node_modules/process/browser.js"),console=__webpack_require__("./node_modules/console-browserify/index.js");Object.defineProperty(exports,"__esModule",{value:!0}),exports.LRUCache=void 0;const perf="object"==typeof performance&&performance&&"function"==typeof performance.now?performance:Date,warned=new Set,PROCESS="object"==typeof process&&process?process:{},emitWarning=(msg,type,code,fn)=>{"function"==typeof PROCESS.emitWarning?PROCESS.emitWarning(msg,type,code,fn):console.error(`[${code}] ${type}: ${msg}`)};let AC=globalThis.AbortController,AS=globalThis.AbortSignal;if(void 0===AC){AS=class AbortSignal{onabort;_onabort=[];reason;aborted=!1;addEventListener(_,fn){this._onabort.push(fn)}},AC=class AbortController{constructor(){warnACPolyfill()}signal=new AS;abort(reason){if(!this.signal.aborted){this.signal.reason=reason,this.signal.aborted=!0;for(const fn of this.signal._onabort)fn(reason);this.signal.onabort?.(reason)}}};let printACPolyfillWarning="1"!==PROCESS.env?.LRU_CACHE_IGNORE_AC_WARNING;const warnACPolyfill=()=>{printACPolyfillWarning&&(printACPolyfillWarning=!1,emitWarning("AbortController is not defined. If using lru-cache in node 14, load an AbortController polyfill from the `node-abort-controller` package. A minimal polyfill is provided for use by LRUCache.fetch(), but it should not be relied upon in other contexts (eg, passing it to other APIs that use AbortController/AbortSignal might have undesirable effects). You may disable this with LRU_CACHE_IGNORE_AC_WARNING=1 in the env.","NO_ABORT_CONTROLLER","ENOTSUP",warnACPolyfill))}}Symbol("type");const isPosInt=n=>n&&n===Math.floor(n)&&n>0&&isFinite(n),getUintArray=max=>isPosInt(max)?max<=Math.pow(2,8)?Uint8Array:max<=Math.pow(2,16)?Uint16Array:max<=Math.pow(2,32)?Uint32Array:max<=Number.MAX_SAFE_INTEGER?ZeroArray:null:null;class ZeroArray extends Array{constructor(size){super(size),this.fill(0)}}class Stack{heap;length;static#constructing=!1;static create(max){const HeapCls=getUintArray(max);if(!HeapCls)return[];Stack.#constructing=!0;const s=new Stack(max,HeapCls);return Stack.#constructing=!1,s}constructor(max,HeapCls){if(!Stack.#constructing)throw new TypeError("instantiate Stack using Stack.create(n)");this.heap=new HeapCls(max),this.length=0}push(n){this.heap[this.length++]=n}pop(){return this.heap[--this.length]}}class LRUCache{#max;#maxSize;#dispose;#disposeAfter;#fetchMethod;ttl;ttlResolution;ttlAutopurge;updateAgeOnGet;updateAgeOnHas;allowStale;noDisposeOnSet;noUpdateTTL;maxEntrySize;sizeCalculation;noDeleteOnFetchRejection;noDeleteOnStaleGet;allowStaleOnFetchAbort;allowStaleOnFetchRejection;ignoreFetchAbort;#size;#calculatedSize;#keyMap;#keyList;#valList;#next;#prev;#head;#tail;#free;#disposed;#sizes;#starts;#ttls;#hasDispose;#hasFetchMethod;#hasDisposeAfter;static unsafeExposeInternals(c){return{starts:c.#starts,ttls:c.#ttls,sizes:c.#sizes,keyMap:c.#keyMap,keyList:c.#keyList,valList:c.#valList,next:c.#next,prev:c.#prev,get head(){return c.#head},get tail(){return c.#tail},free:c.#free,isBackgroundFetch:p=>c.#isBackgroundFetch(p),backgroundFetch:(k,index,options,context)=>c.#backgroundFetch(k,index,options,context),moveToTail:index=>c.#moveToTail(index),indexes:options=>c.#indexes(options),rindexes:options=>c.#rindexes(options),isStale:index=>c.#isStale(index)}}get max(){return this.#max}get maxSize(){return this.#maxSize}get calculatedSize(){return this.#calculatedSize}get size(){return this.#size}get fetchMethod(){return this.#fetchMethod}get dispose(){return this.#dispose}get disposeAfter(){return this.#disposeAfter}constructor(options){const{max=0,ttl,ttlResolution=1,ttlAutopurge,updateAgeOnGet,updateAgeOnHas,allowStale,dispose,disposeAfter,noDisposeOnSet,noUpdateTTL,maxSize=0,maxEntrySize=0,sizeCalculation,fetchMethod,noDeleteOnFetchRejection,noDeleteOnStaleGet,allowStaleOnFetchRejection,allowStaleOnFetchAbort,ignoreFetchAbort}=options;if(0!==max&&!isPosInt(max))throw new TypeError("max option must be a nonnegative integer");const UintArray=max?getUintArray(max):Array;if(!UintArray)throw new Error("invalid max value: "+max);if(this.#max=max,this.#maxSize=maxSize,this.maxEntrySize=maxEntrySize||this.#maxSize,this.sizeCalculation=sizeCalculation,this.sizeCalculation){if(!this.#maxSize&&!this.maxEntrySize)throw new TypeError("cannot set sizeCalculation without setting maxSize or maxEntrySize");if("function"!=typeof this.sizeCalculation)throw new TypeError("sizeCalculation set to non-function")}if(void 0!==fetchMethod&&"function"!=typeof fetchMethod)throw new TypeError("fetchMethod must be a function if specified");if(this.#fetchMethod=fetchMethod,this.#hasFetchMethod=!!fetchMethod,this.#keyMap=new Map,this.#keyList=new Array(max).fill(void 0),this.#valList=new Array(max).fill(void 0),this.#next=new UintArray(max),this.#prev=new UintArray(max),this.#head=0,this.#tail=0,this.#free=Stack.create(max),this.#size=0,this.#calculatedSize=0,"function"==typeof dispose&&(this.#dispose=dispose),"function"==typeof disposeAfter?(this.#disposeAfter=disposeAfter,this.#disposed=[]):(this.#disposeAfter=void 0,this.#disposed=void 0),this.#hasDispose=!!this.#dispose,this.#hasDisposeAfter=!!this.#disposeAfter,this.noDisposeOnSet=!!noDisposeOnSet,this.noUpdateTTL=!!noUpdateTTL,this.noDeleteOnFetchRejection=!!noDeleteOnFetchRejection,this.allowStaleOnFetchRejection=!!allowStaleOnFetchRejection,this.allowStaleOnFetchAbort=!!allowStaleOnFetchAbort,this.ignoreFetchAbort=!!ignoreFetchAbort,0!==this.maxEntrySize){if(0!==this.#maxSize&&!isPosInt(this.#maxSize))throw new TypeError("maxSize must be a positive integer if specified");if(!isPosInt(this.maxEntrySize))throw new TypeError("maxEntrySize must be a positive integer if specified");this.#initializeSizeTracking()}if(this.allowStale=!!allowStale,this.noDeleteOnStaleGet=!!noDeleteOnStaleGet,this.updateAgeOnGet=!!updateAgeOnGet,this.updateAgeOnHas=!!updateAgeOnHas,this.ttlResolution=isPosInt(ttlResolution)||0===ttlResolution?ttlResolution:1,this.ttlAutopurge=!!ttlAutopurge,this.ttl=ttl||0,this.ttl){if(!isPosInt(this.ttl))throw new TypeError("ttl must be a positive integer if specified");this.#initializeTTLTracking()}if(0===this.#max&&0===this.ttl&&0===this.#maxSize)throw new TypeError("At least one of max, maxSize, or ttl is required");if(!this.ttlAutopurge&&!this.#max&&!this.#maxSize){const code="LRU_CACHE_UNBOUNDED";if((code=>!warned.has(code))(code)){warned.add(code);emitWarning("TTL caching without ttlAutopurge, max, or maxSize can result in unbounded memory consumption.","UnboundedCacheWarning",code,LRUCache)}}}getRemainingTTL(key){return this.#keyMap.has(key)?1/0:0}#initializeTTLTracking(){const ttls=new ZeroArray(this.#max),starts=new ZeroArray(this.#max);this.#ttls=ttls,this.#starts=starts,this.#setItemTTL=(index,ttl,start=perf.now())=>{if(starts[index]=0!==ttl?start:0,ttls[index]=ttl,0!==ttl&&this.ttlAutopurge){const t=setTimeout((()=>{this.#isStale(index)&&this.delete(this.#keyList[index])}),ttl+1);t.unref&&t.unref()}},this.#updateItemAge=index=>{starts[index]=0!==ttls[index]?perf.now():0},this.#statusTTL=(status,index)=>{if(ttls[index]){const ttl=ttls[index],start=starts[index];if(!ttl||!start)return;status.ttl=ttl,status.start=start,status.now=cachedNow||getNow();const age=status.now-start;status.remainingTTL=ttl-age}};let cachedNow=0;const getNow=()=>{const n=perf.now();if(this.ttlResolution>0){cachedNow=n;const t=setTimeout((()=>cachedNow=0),this.ttlResolution);t.unref&&t.unref()}return n};this.getRemainingTTL=key=>{const index=this.#keyMap.get(key);if(void 0===index)return 0;const ttl=ttls[index],start=starts[index];if(!ttl||!start)return 1/0;return ttl-((cachedNow||getNow())-start)},this.#isStale=index=>{const s=starts[index],t=ttls[index];return!!t&&!!s&&(cachedNow||getNow())-s>t}}#updateItemAge=()=>{};#statusTTL=()=>{};#setItemTTL=()=>{};#isStale=()=>!1;#initializeSizeTracking(){const sizes=new ZeroArray(this.#max);this.#calculatedSize=0,this.#sizes=sizes,this.#removeItemSize=index=>{this.#calculatedSize-=sizes[index],sizes[index]=0},this.#requireSize=(k,v,size,sizeCalculation)=>{if(this.#isBackgroundFetch(v))return 0;if(!isPosInt(size)){if(!sizeCalculation)throw new TypeError("invalid size value (must be positive integer). When maxSize or maxEntrySize is used, sizeCalculation or size must be set.");if("function"!=typeof sizeCalculation)throw new TypeError("sizeCalculation must be a function");if(size=sizeCalculation(v,k),!isPosInt(size))throw new TypeError("sizeCalculation return invalid (expect positive integer)")}return size},this.#addItemSize=(index,size,status)=>{if(sizes[index]=size,this.#maxSize){const maxSize=this.#maxSize-sizes[index];for(;this.#calculatedSize>maxSize;)this.#evict(!0)}this.#calculatedSize+=sizes[index],status&&(status.entrySize=size,status.totalCalculatedSize=this.#calculatedSize)}}#removeItemSize=_i=>{};#addItemSize=(_i,_s,_st)=>{};#requireSize=(_k,_v,size,sizeCalculation)=>{if(size||sizeCalculation)throw new TypeError("cannot set size without setting maxSize or maxEntrySize on cache");return 0};*#indexes({allowStale=this.allowStale}={}){if(this.#size)for(let i=this.#tail;this.#isValidIndex(i)&&(!allowStale&&this.#isStale(i)||(yield i),i!==this.#head);)i=this.#prev[i]}*#rindexes({allowStale=this.allowStale}={}){if(this.#size)for(let i=this.#head;this.#isValidIndex(i)&&(!allowStale&&this.#isStale(i)||(yield i),i!==this.#tail);)i=this.#next[i]}#isValidIndex(index){return void 0!==index&&this.#keyMap.get(this.#keyList[index])===index}*entries(){for(const i of this.#indexes())void 0===this.#valList[i]||void 0===this.#keyList[i]||this.#isBackgroundFetch(this.#valList[i])||(yield[this.#keyList[i],this.#valList[i]])}*rentries(){for(const i of this.#rindexes())void 0===this.#valList[i]||void 0===this.#keyList[i]||this.#isBackgroundFetch(this.#valList[i])||(yield[this.#keyList[i],this.#valList[i]])}*keys(){for(const i of this.#indexes()){const k=this.#keyList[i];void 0===k||this.#isBackgroundFetch(this.#valList[i])||(yield k)}}*rkeys(){for(const i of this.#rindexes()){const k=this.#keyList[i];void 0===k||this.#isBackgroundFetch(this.#valList[i])||(yield k)}}*values(){for(const i of this.#indexes()){void 0===this.#valList[i]||this.#isBackgroundFetch(this.#valList[i])||(yield this.#valList[i])}}*rvalues(){for(const i of this.#rindexes()){void 0===this.#valList[i]||this.#isBackgroundFetch(this.#valList[i])||(yield this.#valList[i])}}[Symbol.iterator](){return this.entries()}find(fn,getOptions={}){for(const i of this.#indexes()){const v=this.#valList[i],value=this.#isBackgroundFetch(v)?v.__staleWhileFetching:v;if(void 0!==value&&fn(value,this.#keyList[i],this))return this.get(this.#keyList[i],getOptions)}}forEach(fn,thisp=this){for(const i of this.#indexes()){const v=this.#valList[i],value=this.#isBackgroundFetch(v)?v.__staleWhileFetching:v;void 0!==value&&fn.call(thisp,value,this.#keyList[i],this)}}rforEach(fn,thisp=this){for(const i of this.#rindexes()){const v=this.#valList[i],value=this.#isBackgroundFetch(v)?v.__staleWhileFetching:v;void 0!==value&&fn.call(thisp,value,this.#keyList[i],this)}}purgeStale(){let deleted=!1;for(const i of this.#rindexes({allowStale:!0}))this.#isStale(i)&&(this.delete(this.#keyList[i]),deleted=!0);return deleted}info(key){const i=this.#keyMap.get(key);if(void 0===i)return;const v=this.#valList[i],value=this.#isBackgroundFetch(v)?v.__staleWhileFetching:v;if(void 0===value)return;const entry={value};if(this.#ttls&&this.#starts){const ttl=this.#ttls[i],start=this.#starts[i];if(ttl&&start){const remain=ttl-(perf.now()-start);entry.ttl=remain,entry.start=Date.now()}}return this.#sizes&&(entry.size=this.#sizes[i]),entry}dump(){const arr=[];for(const i of this.#indexes({allowStale:!0})){const key=this.#keyList[i],v=this.#valList[i],value=this.#isBackgroundFetch(v)?v.__staleWhileFetching:v;if(void 0===value||void 0===key)continue;const entry={value};if(this.#ttls&&this.#starts){entry.ttl=this.#ttls[i];const age=perf.now()-this.#starts[i];entry.start=Math.floor(Date.now()-age)}this.#sizes&&(entry.size=this.#sizes[i]),arr.unshift([key,entry])}return arr}load(arr){this.clear();for(const[key,entry]of arr){if(entry.start){const age=Date.now()-entry.start;entry.start=perf.now()-age}this.set(key,entry.value,entry)}}set(k,v,setOptions={}){if(void 0===v)return this.delete(k),this;const{ttl=this.ttl,start,noDisposeOnSet=this.noDisposeOnSet,sizeCalculation=this.sizeCalculation,status}=setOptions;let{noUpdateTTL=this.noUpdateTTL}=setOptions;const size=this.#requireSize(k,v,setOptions.size||0,sizeCalculation);if(this.maxEntrySize&&size>this.maxEntrySize)return status&&(status.set="miss",status.maxEntrySizeExceeded=!0),this.delete(k),this;let index=0===this.#size?void 0:this.#keyMap.get(k);if(void 0===index)index=0===this.#size?this.#tail:0!==this.#free.length?this.#free.pop():this.#size===this.#max?this.#evict(!1):this.#size,this.#keyList[index]=k,this.#valList[index]=v,this.#keyMap.set(k,index),this.#next[this.#tail]=index,this.#prev[index]=this.#tail,this.#tail=index,this.#size++,this.#addItemSize(index,size,status),status&&(status.set="add"),noUpdateTTL=!1;else{this.#moveToTail(index);const oldVal=this.#valList[index];if(v!==oldVal){if(this.#hasFetchMethod&&this.#isBackgroundFetch(oldVal)){oldVal.__abortController.abort(new Error("replaced"));const{__staleWhileFetching:s}=oldVal;void 0===s||noDisposeOnSet||(this.#hasDispose&&this.#dispose?.(s,k,"set"),this.#hasDisposeAfter&&this.#disposed?.push([s,k,"set"]))}else noDisposeOnSet||(this.#hasDispose&&this.#dispose?.(oldVal,k,"set"),this.#hasDisposeAfter&&this.#disposed?.push([oldVal,k,"set"]));if(this.#removeItemSize(index),this.#addItemSize(index,size,status),this.#valList[index]=v,status){status.set="replace";const oldValue=oldVal&&this.#isBackgroundFetch(oldVal)?oldVal.__staleWhileFetching:oldVal;void 0!==oldValue&&(status.oldValue=oldValue)}}else status&&(status.set="update")}if(0===ttl||this.#ttls||this.#initializeTTLTracking(),this.#ttls&&(noUpdateTTL||this.#setItemTTL(index,ttl,start),status&&this.#statusTTL(status,index)),!noDisposeOnSet&&this.#hasDisposeAfter&&this.#disposed){const dt=this.#disposed;let task;for(;task=dt?.shift();)this.#disposeAfter?.(...task)}return this}pop(){try{for(;this.#size;){const val=this.#valList[this.#head];if(this.#evict(!0),this.#isBackgroundFetch(val)){if(val.__staleWhileFetching)return val.__staleWhileFetching}else if(void 0!==val)return val}}finally{if(this.#hasDisposeAfter&&this.#disposed){const dt=this.#disposed;let task;for(;task=dt?.shift();)this.#disposeAfter?.(...task)}}}#evict(free){const head=this.#head,k=this.#keyList[head],v=this.#valList[head];return this.#hasFetchMethod&&this.#isBackgroundFetch(v)?v.__abortController.abort(new Error("evicted")):(this.#hasDispose||this.#hasDisposeAfter)&&(this.#hasDispose&&this.#dispose?.(v,k,"evict"),this.#hasDisposeAfter&&this.#disposed?.push([v,k,"evict"])),this.#removeItemSize(head),free&&(this.#keyList[head]=void 0,this.#valList[head]=void 0,this.#free.push(head)),1===this.#size?(this.#head=this.#tail=0,this.#free.length=0):this.#head=this.#next[head],this.#keyMap.delete(k),this.#size--,head}has(k,hasOptions={}){const{updateAgeOnHas=this.updateAgeOnHas,status}=hasOptions,index=this.#keyMap.get(k);if(void 0!==index){const v=this.#valList[index];if(this.#isBackgroundFetch(v)&&void 0===v.__staleWhileFetching)return!1;if(!this.#isStale(index))return updateAgeOnHas&&this.#updateItemAge(index),status&&(status.has="hit",this.#statusTTL(status,index)),!0;status&&(status.has="stale",this.#statusTTL(status,index))}else status&&(status.has="miss");return!1}peek(k,peekOptions={}){const{allowStale=this.allowStale}=peekOptions,index=this.#keyMap.get(k);if(void 0===index||!allowStale&&this.#isStale(index))return;const v=this.#valList[index];return this.#isBackgroundFetch(v)?v.__staleWhileFetching:v}#backgroundFetch(k,index,options,context){const v=void 0===index?void 0:this.#valList[index];if(this.#isBackgroundFetch(v))return v;const ac=new AC,{signal}=options;signal?.addEventListener("abort",(()=>ac.abort(signal.reason)),{signal:ac.signal});const fetchOpts={signal:ac.signal,options,context},cb=(v,updateCache=!1)=>{const{aborted}=ac.signal,ignoreAbort=options.ignoreFetchAbort&&void 0!==v;if(options.status&&(aborted&&!updateCache?(options.status.fetchAborted=!0,options.status.fetchError=ac.signal.reason,ignoreAbort&&(options.status.fetchAbortIgnored=!0)):options.status.fetchResolved=!0),aborted&&!ignoreAbort&&!updateCache)return fetchFail(ac.signal.reason);const bf=p;return this.#valList[index]===p&&(void 0===v?bf.__staleWhileFetching?this.#valList[index]=bf.__staleWhileFetching:this.delete(k):(options.status&&(options.status.fetchUpdated=!0),this.set(k,v,fetchOpts.options))),v},fetchFail=er=>{const{aborted}=ac.signal,allowStaleAborted=aborted&&options.allowStaleOnFetchAbort,allowStale=allowStaleAborted||options.allowStaleOnFetchRejection,noDelete=allowStale||options.noDeleteOnFetchRejection,bf=p;if(this.#valList[index]===p){!noDelete||void 0===bf.__staleWhileFetching?this.delete(k):allowStaleAborted||(this.#valList[index]=bf.__staleWhileFetching)}if(allowStale)return options.status&&void 0!==bf.__staleWhileFetching&&(options.status.returnedStale=!0),bf.__staleWhileFetching;if(bf.__returned===bf)throw er};options.status&&(options.status.fetchDispatched=!0);const p=new Promise(((res,rej)=>{const fmp=this.#fetchMethod?.(k,v,fetchOpts);fmp&&fmp instanceof Promise&&fmp.then((v=>res(void 0===v?void 0:v)),rej),ac.signal.addEventListener("abort",(()=>{options.ignoreFetchAbort&&!options.allowStaleOnFetchAbort||(res(void 0),options.allowStaleOnFetchAbort&&(res=v=>cb(v,!0)))}))})).then(cb,(er=>(options.status&&(options.status.fetchRejected=!0,options.status.fetchError=er),fetchFail(er)))),bf=Object.assign(p,{__abortController:ac,__staleWhileFetching:v,__returned:void 0});return void 0===index?(this.set(k,bf,{...fetchOpts.options,status:void 0}),index=this.#keyMap.get(k)):this.#valList[index]=bf,bf}#isBackgroundFetch(p){if(!this.#hasFetchMethod)return!1;const b=p;return!!b&&b instanceof Promise&&b.hasOwnProperty("__staleWhileFetching")&&b.__abortController instanceof AC}async fetch(k,fetchOptions={}){const{allowStale=this.allowStale,updateAgeOnGet=this.updateAgeOnGet,noDeleteOnStaleGet=this.noDeleteOnStaleGet,ttl=this.ttl,noDisposeOnSet=this.noDisposeOnSet,size=0,sizeCalculation=this.sizeCalculation,noUpdateTTL=this.noUpdateTTL,noDeleteOnFetchRejection=this.noDeleteOnFetchRejection,allowStaleOnFetchRejection=this.allowStaleOnFetchRejection,ignoreFetchAbort=this.ignoreFetchAbort,allowStaleOnFetchAbort=this.allowStaleOnFetchAbort,context,forceRefresh=!1,status,signal}=fetchOptions;if(!this.#hasFetchMethod)return status&&(status.fetch="get"),this.get(k,{allowStale,updateAgeOnGet,noDeleteOnStaleGet,status});const options={allowStale,updateAgeOnGet,noDeleteOnStaleGet,ttl,noDisposeOnSet,size,sizeCalculation,noUpdateTTL,noDeleteOnFetchRejection,allowStaleOnFetchRejection,allowStaleOnFetchAbort,ignoreFetchAbort,status,signal};let index=this.#keyMap.get(k);if(void 0===index){status&&(status.fetch="miss");const p=this.#backgroundFetch(k,index,options,context);return p.__returned=p}{const v=this.#valList[index];if(this.#isBackgroundFetch(v)){const stale=allowStale&&void 0!==v.__staleWhileFetching;return status&&(status.fetch="inflight",stale&&(status.returnedStale=!0)),stale?v.__staleWhileFetching:v.__returned=v}const isStale=this.#isStale(index);if(!forceRefresh&&!isStale)return status&&(status.fetch="hit"),this.#moveToTail(index),updateAgeOnGet&&this.#updateItemAge(index),status&&this.#statusTTL(status,index),v;const p=this.#backgroundFetch(k,index,options,context),staleVal=void 0!==p.__staleWhileFetching&&allowStale;return status&&(status.fetch=isStale?"stale":"refresh",staleVal&&isStale&&(status.returnedStale=!0)),staleVal?p.__staleWhileFetching:p.__returned=p}}get(k,getOptions={}){const{allowStale=this.allowStale,updateAgeOnGet=this.updateAgeOnGet,noDeleteOnStaleGet=this.noDeleteOnStaleGet,status}=getOptions,index=this.#keyMap.get(k);if(void 0!==index){const value=this.#valList[index],fetching=this.#isBackgroundFetch(value);return status&&this.#statusTTL(status,index),this.#isStale(index)?(status&&(status.get="stale"),fetching?(status&&allowStale&&void 0!==value.__staleWhileFetching&&(status.returnedStale=!0),allowStale?value.__staleWhileFetching:void 0):(noDeleteOnStaleGet||this.delete(k),status&&allowStale&&(status.returnedStale=!0),allowStale?value:void 0)):(status&&(status.get="hit"),fetching?value.__staleWhileFetching:(this.#moveToTail(index),updateAgeOnGet&&this.#updateItemAge(index),value))}status&&(status.get="miss")}#connect(p,n){this.#prev[n]=p,this.#next[p]=n}#moveToTail(index){index!==this.#tail&&(index===this.#head?this.#head=this.#next[index]:this.#connect(this.#prev[index],this.#next[index]),this.#connect(this.#tail,index),this.#tail=index)}delete(k){let deleted=!1;if(0!==this.#size){const index=this.#keyMap.get(k);if(void 0!==index)if(deleted=!0,1===this.#size)this.clear();else{this.#removeItemSize(index);const v=this.#valList[index];if(this.#isBackgroundFetch(v)?v.__abortController.abort(new Error("deleted")):(this.#hasDispose||this.#hasDisposeAfter)&&(this.#hasDispose&&this.#dispose?.(v,k,"delete"),this.#hasDisposeAfter&&this.#disposed?.push([v,k,"delete"])),this.#keyMap.delete(k),this.#keyList[index]=void 0,this.#valList[index]=void 0,index===this.#tail)this.#tail=this.#prev[index];else if(index===this.#head)this.#head=this.#next[index];else{const pi=this.#prev[index];this.#next[pi]=this.#next[index];const ni=this.#next[index];this.#prev[ni]=this.#prev[index]}this.#size--,this.#free.push(index)}}if(this.#hasDisposeAfter&&this.#disposed?.length){const dt=this.#disposed;let task;for(;task=dt?.shift();)this.#disposeAfter?.(...task)}return deleted}clear(){for(const index of this.#rindexes({allowStale:!0})){const v=this.#valList[index];if(this.#isBackgroundFetch(v))v.__abortController.abort(new Error("deleted"));else{const k=this.#keyList[index];this.#hasDispose&&this.#dispose?.(v,k,"delete"),this.#hasDisposeAfter&&this.#disposed?.push([v,k,"delete"])}}if(this.#keyMap.clear(),this.#valList.fill(void 0),this.#keyList.fill(void 0),this.#ttls&&this.#starts&&(this.#ttls.fill(0),this.#starts.fill(0)),this.#sizes&&this.#sizes.fill(0),this.#head=0,this.#tail=0,this.#free.length=0,this.#calculatedSize=0,this.#size=0,this.#hasDisposeAfter&&this.#disposed){const dt=this.#disposed;let task;for(;task=dt?.shift();)this.#disposeAfter?.(...task)}}}exports.LRUCache=LRUCache},"./node_modules/@octokit/auth-oauth-app/dist-web/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{createOAuthAppAuth:()=>createOAuthAppAuth,createOAuthUserAuth:()=>_octokit_auth_oauth_user__WEBPACK_IMPORTED_MODULE_1__.createOAuthUserAuth});var universal_user_agent__WEBPACK_IMPORTED_MODULE_3__=__webpack_require__("./node_modules/universal-user-agent/dist-web/index.js"),_octokit_request__WEBPACK_IMPORTED_MODULE_2__=__webpack_require__("./node_modules/@octokit/request/dist-web/index.js"),btoa_lite__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/btoa-lite/btoa-browser.js"),btoa_lite__WEBPACK_IMPORTED_MODULE_0___default=__webpack_require__.n(btoa_lite__WEBPACK_IMPORTED_MODULE_0__),_octokit_auth_oauth_user__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/@octokit/auth-oauth-user/dist-web/index.js");async function auth(state,authOptions){if("oauth-app"===authOptions.type)return{type:"oauth-app",clientId:state.clientId,clientSecret:state.clientSecret,clientType:state.clientType,headers:{authorization:`basic ${btoa_lite__WEBPACK_IMPORTED_MODULE_0___default()(`${state.clientId}:${state.clientSecret}`)}`}};if("factory"in authOptions){const{type,...options}={...authOptions,...state};return authOptions.factory(options)}const common={clientId:state.clientId,clientSecret:state.clientSecret,request:state.request,...authOptions};return(state.clientType,await(0,_octokit_auth_oauth_user__WEBPACK_IMPORTED_MODULE_1__.createOAuthUserAuth)({...common,clientType:state.clientType}))()}async function hook(state,request2,route,parameters){let endpoint=request2.endpoint.merge(route,parameters);if(/\/login\/(oauth\/access_token|device\/code)$/.test(endpoint.url))return request2(endpoint);if("github-app"===state.clientType&&!(0,_octokit_auth_oauth_user__WEBPACK_IMPORTED_MODULE_1__.requiresBasicAuth)(endpoint.url))throw new Error(`[@octokit/auth-oauth-app] GitHub Apps cannot use their client ID/secret for basic authentication for endpoints other than "/applications/{client_id}/**". "${endpoint.method} ${endpoint.url}" is not supported.`);const credentials=btoa_lite__WEBPACK_IMPORTED_MODULE_0___default()(`${state.clientId}:${state.clientSecret}`);endpoint.headers.authorization=`basic ${credentials}`;try{return await request2(endpoint)}catch(error){if(401!==error.status)throw error;throw error.message=`[@octokit/auth-oauth-app] "${endpoint.method} ${endpoint.url}" does not support clientId/clientSecret basic authentication.`,error}}var VERSION="7.0.1";function createOAuthAppAuth(options){const state=Object.assign({request:_octokit_request__WEBPACK_IMPORTED_MODULE_2__.request.defaults({headers:{"user-agent":`octokit-auth-oauth-app.js/${VERSION} ${(0,universal_user_agent__WEBPACK_IMPORTED_MODULE_3__.getUserAgent)()}`}}),clientType:"oauth-app"},options);return Object.assign(auth.bind(null,state),{hook:hook.bind(null,state)})}},"./node_modules/@octokit/auth-oauth-user/dist-web/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{createOAuthUserAuth:()=>createOAuthUserAuth,requiresBasicAuth:()=>requiresBasicAuth});var dist_web=__webpack_require__("./node_modules/universal-user-agent/dist-web/index.js"),request_dist_web=__webpack_require__("./node_modules/@octokit/request/dist-web/index.js"),create_device_code=__webpack_require__("./node_modules/@octokit/oauth-methods/dist-src/create-device-code.js"),exchange_device_code=__webpack_require__("./node_modules/@octokit/oauth-methods/dist-src/exchange-device-code.js");async function getOAuthAccessToken(state,options){const cachedAuthentication=function getCachedAuthentication(state,auth2){if(!0===auth2.refresh)return!1;if(!state.authentication)return!1;if("github-app"===state.clientType)return state.authentication;const authentication=state.authentication,newScope=("scopes"in auth2&&auth2.scopes||state.scopes).join(" "),currentScope=authentication.scopes.join(" ");return newScope===currentScope&&authentication}(state,options.auth);if(cachedAuthentication)return cachedAuthentication;const{data:verification}=await(0,create_device_code.T)({clientType:state.clientType,clientId:state.clientId,request:options.request||state.request,scopes:options.auth.scopes||state.scopes});await state.onVerification(verification);const authentication=await waitForAccessToken(options.request||state.request,state.clientId,state.clientType,verification);return state.authentication=authentication,authentication}async function wait(seconds){await new Promise((resolve=>setTimeout(resolve,1e3*seconds)))}async function waitForAccessToken(request,clientId,clientType,verification){try{const options={clientId,request,code:verification.device_code},{authentication}="oauth-app"===clientType?await(0,exchange_device_code.i)({...options,clientType:"oauth-app"}):await(0,exchange_device_code.i)({...options,clientType:"github-app"});return{type:"token",tokenType:"oauth",...authentication}}catch(error){if(!error.response)throw error;const errorType=error.response.data.error;if("authorization_pending"===errorType)return await wait(verification.interval),waitForAccessToken(request,clientId,clientType,verification);if("slow_down"===errorType)return await wait(verification.interval+5),waitForAccessToken(request,clientId,clientType,verification);throw error}}async function auth(state,authOptions){return getOAuthAccessToken(state,{auth:authOptions})}async function hook(state,request,route,parameters){let endpoint=request.endpoint.merge(route,parameters);if(/\/login\/(oauth\/access_token|device\/code)$/.test(endpoint.url))return request(endpoint);const{token}=await getOAuthAccessToken(state,{request,auth:{type:"oauth"}});return endpoint.headers.authorization=`token ${token}`,request(endpoint)}var VERSION="6.0.1";function createOAuthDeviceAuth(options){const requestWithDefaults=options.request||request_dist_web.request.defaults({headers:{"user-agent":`octokit-auth-oauth-device.js/${VERSION} ${(0,dist_web.getUserAgent)()}`}}),{request=requestWithDefaults,...otherOptions}=options,state="github-app"===options.clientType?{...otherOptions,clientType:"github-app",request}:{...otherOptions,clientType:"oauth-app",request,scopes:options.scopes||[]};if(!options.clientId)throw new Error('[@octokit/auth-oauth-device] "clientId" option must be set (https://github.com/octokit/auth-oauth-device.js#usage)');if(!options.onVerification)throw new Error('[@octokit/auth-oauth-device] "onVerification" option must be a function (https://github.com/octokit/auth-oauth-device.js#usage)');return Object.assign(auth.bind(null,state),{hook:hook.bind(null,state)})}var exchange_web_flow_code=__webpack_require__("./node_modules/@octokit/oauth-methods/dist-src/exchange-web-flow-code.js"),refresh_token=__webpack_require__("./node_modules/@octokit/oauth-methods/dist-src/refresh-token.js"),check_token=__webpack_require__("./node_modules/@octokit/oauth-methods/dist-src/check-token.js"),reset_token=__webpack_require__("./node_modules/@octokit/oauth-methods/dist-src/reset-token.js"),delete_token=__webpack_require__("./node_modules/@octokit/oauth-methods/dist-src/delete-token.js"),delete_authorization=__webpack_require__("./node_modules/@octokit/oauth-methods/dist-src/delete-authorization.js"),btoa_browser=__webpack_require__("./node_modules/btoa-lite/btoa-browser.js"),btoa_browser_default=__webpack_require__.n(btoa_browser),dist_web_VERSION="4.0.1";async function getAuthentication(state){if("code"in state.strategyOptions){const{authentication}=await(0,exchange_web_flow_code.y)({clientId:state.clientId,clientSecret:state.clientSecret,clientType:state.clientType,onTokenCreated:state.onTokenCreated,...state.strategyOptions,request:state.request});return{type:"token",tokenType:"oauth",...authentication}}if("onVerification"in state.strategyOptions){const deviceAuth=createOAuthDeviceAuth({clientType:state.clientType,clientId:state.clientId,onTokenCreated:state.onTokenCreated,...state.strategyOptions,request:state.request}),authentication=await deviceAuth({type:"oauth"});return{clientSecret:state.clientSecret,...authentication}}if("token"in state.strategyOptions)return{type:"token",tokenType:"oauth",clientId:state.clientId,clientSecret:state.clientSecret,clientType:state.clientType,onTokenCreated:state.onTokenCreated,...state.strategyOptions};throw new Error("[@octokit/auth-oauth-user] Invalid strategy options")}async function dist_web_auth(state,options={}){if(state.authentication||(state.authentication=(state.clientType,await getAuthentication(state))),state.authentication.invalid)throw new Error("[@octokit/auth-oauth-user] Token is invalid");const currentAuthentication=state.authentication;if("expiresAt"in currentAuthentication&&("refresh"===options.type||new Date(currentAuthentication.expiresAt)<new Date)){const{authentication}=await(0,refresh_token.g)({clientType:"github-app",clientId:state.clientId,clientSecret:state.clientSecret,refreshToken:currentAuthentication.refreshToken,request:state.request});state.authentication={tokenType:"oauth",type:"token",...authentication}}if("refresh"===options.type){if("oauth-app"===state.clientType)throw new Error("[@octokit/auth-oauth-user] OAuth Apps do not support expiring tokens");if(!currentAuthentication.hasOwnProperty("expiresAt"))throw new Error("[@octokit/auth-oauth-user] Refresh token missing");await(state.onTokenCreated?.(state.authentication,{type:options.type}))}if("check"===options.type||"reset"===options.type){const method="check"===options.type?check_token.a:reset_token.E;try{const{authentication}=await method({clientType:state.clientType,clientId:state.clientId,clientSecret:state.clientSecret,token:state.authentication.token,request:state.request});return state.authentication={tokenType:"oauth",type:"token",...authentication},"reset"===options.type&&await(state.onTokenCreated?.(state.authentication,{type:options.type})),state.authentication}catch(error){throw 404===error.status&&(error.message="[@octokit/auth-oauth-user] Token is invalid",state.authentication.invalid=!0),error}}if("delete"===options.type||"deleteAuthorization"===options.type){const method="delete"===options.type?delete_token.p:delete_authorization.s;try{await method({clientType:state.clientType,clientId:state.clientId,clientSecret:state.clientSecret,token:state.authentication.token,request:state.request})}catch(error){if(404!==error.status)throw error}return state.authentication.invalid=!0,state.authentication}return state.authentication}var ROUTES_REQUIRING_BASIC_AUTH=/\/applications\/[^/]+\/(token|grant)s?/;function requiresBasicAuth(url){return url&&ROUTES_REQUIRING_BASIC_AUTH.test(url)}async function dist_web_hook(state,request,route,parameters={}){const endpoint=request.endpoint.merge(route,parameters);if(/\/login\/(oauth\/access_token|device\/code)$/.test(endpoint.url))return request(endpoint);if(requiresBasicAuth(endpoint.url)){const credentials=btoa_browser_default()(`${state.clientId}:${state.clientSecret}`);return endpoint.headers.authorization=`basic ${credentials}`,request(endpoint)}const{token}=(state.clientType,await dist_web_auth({...state,request}));return endpoint.headers.authorization="token "+token,request(endpoint)}function createOAuthUserAuth({clientId,clientSecret,clientType="oauth-app",request=request_dist_web.request.defaults({headers:{"user-agent":`octokit-auth-oauth-app.js/${dist_web_VERSION} ${(0,dist_web.getUserAgent)()}`}}),onTokenCreated,...strategyOptions}){const state=Object.assign({clientType,clientId,clientSecret,onTokenCreated,strategyOptions,request});return Object.assign(dist_web_auth.bind(null,state),{hook:dist_web_hook.bind(null,state)})}createOAuthUserAuth.VERSION=dist_web_VERSION},"./node_modules/@octokit/auth-unauthenticated/dist-web/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";async function auth(reason){return{type:"unauthenticated",reason}}__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{createUnauthenticatedAuth:()=>createUnauthenticatedAuth});var REGEX_ABUSE_LIMIT_MESSAGE=/\babuse\b/i;async function hook(reason,request,route,parameters){const endpoint=request.endpoint.merge(route,parameters);return request(endpoint).catch((error=>{if(404===error.status)throw error.message=`Not found. May be due to lack of authentication. Reason: ${reason}`,error;if(function isRateLimitError(error){return 403===error.status&&!!error.response&&"0"===error.response.headers["x-ratelimit-remaining"]}(error))throw error.message=`API rate limit exceeded. This maybe caused by the lack of authentication. Reason: ${reason}`,error;if(function isAbuseLimitError(error){return 403===error.status&&REGEX_ABUSE_LIMIT_MESSAGE.test(error.message)}(error))throw error.message=`You have triggered an abuse detection mechanism. This maybe caused by the lack of authentication. Reason: ${reason}`,error;if(401===error.status)throw error.message=`Unauthorized. "${endpoint.method} ${endpoint.url}" failed most likely due to lack of authentication. Reason: ${reason}`,error;throw error.status>=400&&error.status<500&&(error.message=error.message.replace(/\.?$/,`. May be caused by lack of authentication (${reason}).`)),error}))}var createUnauthenticatedAuth=function createUnauthenticatedAuth2(options){if(!options||!options.reason)throw new Error("[@octokit/auth-unauthenticated] No reason passed to createUnauthenticatedAuth");return Object.assign(auth.bind(null,options.reason),{hook:hook.bind(null,options.reason)})}},"./node_modules/@octokit/core/dist-web/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{Octokit:()=>Octokit});var dist_web=__webpack_require__("./node_modules/universal-user-agent/dist-web/index.js"),before_after_hook=__webpack_require__("./node_modules/before-after-hook/index.js"),request_dist_web=__webpack_require__("./node_modules/@octokit/request/dist-web/index.js");var GraphqlResponseError=class extends Error{constructor(request2,headers,response){super(function _buildMessageForResponseErrors(data){return"Request failed due to following response errors:\n"+data.errors.map((e=>` - ${e.message}`)).join("\n")}(response)),this.request=request2,this.headers=headers,this.response=response,this.name="GraphqlResponseError",this.errors=response.errors,this.data=response.data,Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor)}},NON_VARIABLE_OPTIONS=["method","baseUrl","url","headers","request","query","mediaType"],FORBIDDEN_VARIABLE_OPTIONS=["query","method","url"],GHES_V3_SUFFIX_REGEX=/\/api\/v3\/?$/;function withDefaults(request2,newDefaults){const newRequest=request2.defaults(newDefaults);return Object.assign(((query,options)=>function graphql(request2,query,options){if(options){if("string"==typeof query&&"query"in options)return Promise.reject(new Error('[@octokit/graphql] "query" cannot be used as variable name'));for(const key in options)if(FORBIDDEN_VARIABLE_OPTIONS.includes(key))return Promise.reject(new Error(`[@octokit/graphql] "${key}" cannot be used as variable name`))}const parsedOptions="string"==typeof query?Object.assign({query},options):query,requestOptions=Object.keys(parsedOptions).reduce(((result,key)=>NON_VARIABLE_OPTIONS.includes(key)?(result[key]=parsedOptions[key],result):(result.variables||(result.variables={}),result.variables[key]=parsedOptions[key],result)),{}),baseUrl=parsedOptions.baseUrl||request2.endpoint.DEFAULTS.baseUrl;return GHES_V3_SUFFIX_REGEX.test(baseUrl)&&(requestOptions.url=baseUrl.replace(GHES_V3_SUFFIX_REGEX,"/api/graphql")),request2(requestOptions).then((response=>{if(response.data.errors){const headers={};for(const key of Object.keys(response.headers))headers[key]=response.headers[key];throw new GraphqlResponseError(requestOptions,headers,response.data)}return response.data.data}))}(newRequest,query,options)),{defaults:withDefaults.bind(null,newRequest),endpoint:newRequest.endpoint})}withDefaults(request_dist_web.request,{headers:{"user-agent":`octokit-graphql.js/7.0.2 ${(0,dist_web.getUserAgent)()}`},method:"POST",url:"/graphql"});var REGEX_IS_INSTALLATION_LEGACY=/^v1\./,REGEX_IS_INSTALLATION=/^ghs_/,REGEX_IS_USER_TO_SERVER=/^ghu_/;async function auth(token){const isApp=3===token.split(/\./).length,isInstallation=REGEX_IS_INSTALLATION_LEGACY.test(token)||REGEX_IS_INSTALLATION.test(token),isUserToServer=REGEX_IS_USER_TO_SERVER.test(token);return{type:"token",token,tokenType:isApp?"app":isInstallation?"installation":isUserToServer?"user-to-server":"oauth"}}async function hook(token,request,route,parameters){const endpoint=request.endpoint.merge(route,parameters);return endpoint.headers.authorization=function withAuthorizationPrefix(token){return 3===token.split(/\./).length?`bearer ${token}`:`token ${token}`}(token),request(endpoint)}var createTokenAuth=function createTokenAuth2(token){if(!token)throw new Error("[@octokit/auth-token] No token passed to createTokenAuth");if("string"!=typeof token)throw new Error("[@octokit/auth-token] Token passed to createTokenAuth is not a string");return token=token.replace(/^(token|bearer) +/i,""),Object.assign(auth.bind(null,token),{hook:hook.bind(null,token)})},console=__webpack_require__("./node_modules/console-browserify/index.js"),noop=()=>{},consoleWarn=console.warn.bind(console),consoleError=console.error.bind(console),userAgentTrail=`octokit-core.js/5.0.2 ${(0,dist_web.getUserAgent)()}`,Octokit=class{static{this.VERSION="5.0.2"}static defaults(defaults){return class extends(this){constructor(...args){const options=args[0]||{};super("function"!=typeof defaults?Object.assign({},defaults,options,options.userAgent&&defaults.userAgent?{userAgent:`${options.userAgent} ${defaults.userAgent}`}:null):defaults(options))}}}static{this.plugins=[]}static plugin(...newPlugins){const currentPlugins=this.plugins;return class extends(this){static{this.plugins=currentPlugins.concat(newPlugins.filter((plugin=>!currentPlugins.includes(plugin))))}}}constructor(options={}){const hook=new before_after_hook.Collection,requestDefaults={baseUrl:request_dist_web.request.endpoint.DEFAULTS.baseUrl,headers:{},request:Object.assign({},options.request,{hook:hook.bind(null,"request")}),mediaType:{previews:[],format:""}};if(requestDefaults.headers["user-agent"]=options.userAgent?`${options.userAgent} ${userAgentTrail}`:userAgentTrail,options.baseUrl&&(requestDefaults.baseUrl=options.baseUrl),options.previews&&(requestDefaults.mediaType.previews=options.previews),options.timeZone&&(requestDefaults.headers["time-zone"]=options.timeZone),this.request=request_dist_web.request.defaults(requestDefaults),this.graphql=function withCustomRequest(customRequest){return withDefaults(customRequest,{method:"POST",url:"/graphql"})}(this.request).defaults(requestDefaults),this.log=Object.assign({debug:noop,info:noop,warn:consoleWarn,error:consoleError},options.log),this.hook=hook,options.authStrategy){const{authStrategy,...otherOptions}=options,auth=authStrategy(Object.assign({request:this.request,log:this.log,octokit:this,octokitOptions:otherOptions},options.auth));hook.wrap("request",auth.hook),this.auth=auth}else if(options.auth){const auth=createTokenAuth(options.auth);hook.wrap("request",auth.hook),this.auth=auth}else this.auth=async()=>({type:"unauthenticated"});const classConstructor=this.constructor;for(let i=0;i<classConstructor.plugins.length;++i)Object.assign(this,classConstructor.plugins[i](this,options))}}},"./node_modules/@octokit/oauth-app/dist-node/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";var mod,Buffer=__webpack_require__("./node_modules/node-polyfill-webpack-plugin/node_modules/buffer/index.js").Buffer,__create=Object.create,__defProp=Object.defineProperty,__getOwnPropDesc=Object.getOwnPropertyDescriptor,__getOwnPropNames=Object.getOwnPropertyNames,__getProtoOf=Object.getPrototypeOf,__hasOwnProp=Object.prototype.hasOwnProperty,__copyProps=(to,from,except,desc)=>{if(from&&"object"==typeof from||"function"==typeof from)for(let key of __getOwnPropNames(from))__hasOwnProp.call(to,key)||key===except||__defProp(to,key,{get:()=>from[key],enumerable:!(desc=__getOwnPropDesc(from,key))||desc.enumerable});return to},__toESM=(mod,isNodeMode,target)=>(target=null!=mod?__create(__getProtoOf(mod)):{},__copyProps(!isNodeMode&&mod&&mod.__esModule?target:__defProp(target,"default",{value:mod,enumerable:!0}),mod)),dist_src_exports={};((target,all)=>{for(var name in all)__defProp(target,name,{get:all[name],enumerable:!0})})(dist_src_exports,{OAuthApp:()=>OAuthApp,createAWSLambdaAPIGatewayV2Handler:()=>createAWSLambdaAPIGatewayV2Handler,createNodeMiddleware:()=>createNodeMiddleware,createWebWorkerHandler:()=>createWebWorkerHandler,handleRequest:()=>handleRequest,sendNodeResponse:()=>sendResponse,unknownRouteResponse:()=>unknownRouteResponse}),module.exports=(mod=dist_src_exports,__copyProps(__defProp({},"__esModule",{value:!0}),mod));var import_auth_oauth_app=__webpack_require__("./node_modules/@octokit/auth-oauth-app/dist-web/index.js");function addEventHandler(state,eventName,eventHandler){if(Array.isArray(eventName))for(const singleEventName of eventName)addEventHandler(state,singleEventName,eventHandler);else state.eventHandlers[eventName]||(state.eventHandlers[eventName]=[]),state.eventHandlers[eventName].push(eventHandler)}var import_core=__webpack_require__("./node_modules/@octokit/core/dist-web/index.js"),import_universal_user_agent=__webpack_require__("./node_modules/universal-user-agent/dist-web/index.js"),OAuthAppOctokit=import_core.Octokit.defaults({userAgent:`octokit-oauth-app.js/6.0.0 ${(0,import_universal_user_agent.getUserAgent)()}`}),import_auth_oauth_user=__webpack_require__("./node_modules/@octokit/auth-oauth-user/dist-web/index.js");async function emitEvent(state,context){const{name,action}=context;if(state.eventHandlers[`${name}.${action}`])for(const eventHandler of state.eventHandlers[`${name}.${action}`])await eventHandler(context);if(state.eventHandlers[name])for(const eventHandler of state.eventHandlers[name])await eventHandler(context)}async function getUserOctokitWithState(state,options){return state.octokit.auth({type:"oauth-user",...options,async factory(options2){const octokit=new state.Octokit({authStrategy:import_auth_oauth_user.createOAuthUserAuth,auth:options2}),authentication=await octokit.auth({type:"get"});return await emitEvent(state,{name:"token",action:"created",token:authentication.token,scopes:authentication.scopes,authentication,octokit}),octokit}})}var OAuthMethods=__toESM(__webpack_require__("./node_modules/@octokit/oauth-methods/dist-src/index.js"));function getWebFlowAuthorizationUrlWithState(state,options){const optionsWithDefaults={clientId:state.clientId,request:state.octokit.request,...options,allowSignup:state.allowSignup??options.allowSignup,redirectUrl:options.redirectUrl??state.redirectUrl,scopes:options.scopes??state.defaultScopes};return OAuthMethods.getWebFlowAuthorizationUrl({clientType:state.clientType,...optionsWithDefaults})}var OAuthAppAuth=__toESM(__webpack_require__("./node_modules/@octokit/auth-oauth-app/dist-web/index.js"));async function createTokenWithState(state,options){const authentication=await state.octokit.auth({type:"oauth-user",...options});return await emitEvent(state,{name:"token",action:"created",token:authentication.token,scopes:authentication.scopes,authentication,octokit:new state.Octokit({authStrategy:OAuthAppAuth.createOAuthUserAuth,auth:{clientType:state.clientType,clientId:state.clientId,clientSecret:state.clientSecret,token:authentication.token,scopes:authentication.scopes,refreshToken:authentication.refreshToken,expiresAt:authentication.expiresAt,refreshTokenExpiresAt:authentication.refreshTokenExpiresAt}})}),{authentication}}var OAuthMethods2=__toESM(__webpack_require__("./node_modules/@octokit/oauth-methods/dist-src/index.js"));async function checkTokenWithState(state,options){const result=await OAuthMethods2.checkToken({clientType:state.clientType,clientId:state.clientId,clientSecret:state.clientSecret,request:state.octokit.request,...options});return Object.assign(result.authentication,{type:"token",tokenType:"oauth"}),result}var OAuthMethods3=__toESM(__webpack_require__("./node_modules/@octokit/oauth-methods/dist-src/index.js")),import_auth_oauth_user2=__webpack_require__("./node_modules/@octokit/auth-oauth-user/dist-web/index.js");async function resetTokenWithState(state,options){const optionsWithDefaults={clientId:state.clientId,clientSecret:state.clientSecret,request:state.octokit.request,...options};if("oauth-app"===state.clientType){const response2=await OAuthMethods3.resetToken({clientType:"oauth-app",...optionsWithDefaults}),authentication2=Object.assign(response2.authentication,{type:"token",tokenType:"oauth"});return await emitEvent(state,{name:"token",action:"reset",token:response2.authentication.token,scopes:response2.authentication.scopes||void 0,authentication:authentication2,octokit:new state.Octokit({authStrategy:import_auth_oauth_user2.createOAuthUserAuth,auth:{clientType:state.clientType,clientId:state.clientId,clientSecret:state.clientSecret,token:response2.authentication.token,scopes:response2.authentication.scopes}})}),{...response2,authentication:authentication2}}const response=await OAuthMethods3.resetToken({clientType:"github-app",...optionsWithDefaults}),authentication=Object.assign(response.authentication,{type:"token",tokenType:"oauth"});return await emitEvent(state,{name:"token",action:"reset",token:response.authentication.token,authentication,octokit:new state.Octokit({authStrategy:import_auth_oauth_user2.createOAuthUserAuth,auth:{clientType:state.clientType,clientId:state.clientId,clientSecret:state.clientSecret,token:response.authentication.token}})}),{...response,authentication}}var OAuthMethods4=__toESM(__webpack_require__("./node_modules/@octokit/oauth-methods/dist-src/index.js")),import_auth_oauth_user3=__webpack_require__("./node_modules/@octokit/auth-oauth-user/dist-web/index.js");async function refreshTokenWithState(state,options){if("oauth-app"===state.clientType)throw new Error("[@octokit/oauth-app] app.refreshToken() is not supported for OAuth Apps");const response=await OAuthMethods4.refreshToken({clientType:"github-app",clientId:state.clientId,clientSecret:state.clientSecret,request:state.octokit.request,refreshToken:options.refreshToken}),authentication=Object.assign(response.authentication,{type:"token",tokenType:"oauth"});return await emitEvent(state,{name:"token",action:"refreshed",token:response.authentication.token,authentication,octokit:new state.Octokit({authStrategy:import_auth_oauth_user3.createOAuthUserAuth,auth:{clientType:state.clientType,clientId:state.clientId,clientSecret:state.clientSecret,token:response.authentication.token}})}),{...response,authentication}}var OAuthMethods5=__toESM(__webpack_require__("./node_modules/@octokit/oauth-methods/dist-src/index.js")),import_auth_oauth_user4=__webpack_require__("./node_modules/@octokit/auth-oauth-user/dist-web/index.js");async function scopeTokenWithState(state,options){if("oauth-app"===state.clientType)throw new Error("[@octokit/oauth-app] app.scopeToken() is not supported for OAuth Apps");const response=await OAuthMethods5.scopeToken({clientType:"github-app",clientId:state.clientId,clientSecret:state.clientSecret,request:state.octokit.request,...options}),authentication=Object.assign(response.authentication,{type:"token",tokenType:"oauth"});return await emitEvent(state,{name:"token",action:"scoped",token:response.authentication.token,authentication,octokit:new state.Octokit({authStrategy:import_auth_oauth_user4.createOAuthUserAuth,auth:{clientType:state.clientType,clientId:state.clientId,clientSecret:state.clientSecret,token:response.authentication.token}})}),{...response,authentication}}var OAuthMethods6=__toESM(__webpack_require__("./node_modules/@octokit/oauth-methods/dist-src/index.js")),import_auth_unauthenticated=__webpack_require__("./node_modules/@octokit/auth-unauthenticated/dist-web/index.js");async function deleteTokenWithState(state,options){const optionsWithDefaults={clientId:state.clientId,clientSecret:state.clientSecret,request:state.octokit.request,...options},response="oauth-app"===state.clientType?await OAuthMethods6.deleteToken({clientType:"oauth-app",...optionsWithDefaults}):await OAuthMethods6.deleteToken({clientType:"github-app",...optionsWithDefaults});return await emitEvent(state,{name:"token",action:"deleted",token:options.token,octokit:new state.Octokit({authStrategy:import_auth_unauthenticated.createUnauthenticatedAuth,auth:{reason:'Handling "token.deleted" event. The access for the token has been revoked.'}})}),response}var OAuthMethods7=__toESM(__webpack_require__("./node_modules/@octokit/oauth-methods/dist-src/index.js")),import_auth_unauthenticated2=__webpack_require__("./node_modules/@octokit/auth-unauthenticated/dist-web/index.js");async function deleteAuthorizationWithState(state,options){const optionsWithDefaults={clientId:state.clientId,clientSecret:state.clientSecret,request:state.octokit.request,...options},response="oauth-app"===state.clientType?await OAuthMethods7.deleteAuthorization({clientType:"oauth-app",...optionsWithDefaults}):await OAuthMethods7.deleteAuthorization({clientType:"github-app",...optionsWithDefaults});return await emitEvent(state,{name:"token",action:"deleted",token:options.token,octokit:new state.Octokit({authStrategy:import_auth_unauthenticated2.createUnauthenticatedAuth,auth:{reason:'Handling "token.deleted" event. The access for the token has been revoked.'}})}),await emitEvent(state,{name:"authorization",action:"deleted",token:options.token,octokit:new state.Octokit({authStrategy:import_auth_unauthenticated2.createUnauthenticatedAuth,auth:{reason:'Handling "authorization.deleted" event. The access for the app has been revoked.'}})}),response}function unknownRouteResponse(request){return{status:404,headers:{"content-type":"application/json"},text:JSON.stringify({error:`Unknown route: ${request.method} ${request.url}`})}}async function handleRequest(app,{pathPrefix="/api/github/oauth"},request){if("OPTIONS"===request.method)return{status:200,headers:{"access-control-allow-origin":"*","access-control-allow-methods":"*","access-control-allow-headers":"Content-Type, User-Agent, Authorization"}};let{pathname}=new URL(request.url,"http://localhost");if(!pathname.startsWith(`${pathPrefix}/`))return;pathname=pathname.slice(pathPrefix.length+1);const route=[request.method,pathname].join(" "),routes={getLogin:"GET login",getCallback:"GET callback",createToken:"POST token",getToken:"GET token",patchToken:"PATCH token",patchRefreshToken:"PATCH refresh-token",scopeToken:"POST token/scoped",deleteToken:"DELETE token",deleteGrant:"DELETE grant"};if(!Object.values(routes).includes(route))return unknownRouteResponse(request);let json;try{const text=await request.text();json=text?JSON.parse(text):{}}catch(error){return{status:400,headers:{"content-type":"application/json","access-control-allow-origin":"*"},text:JSON.stringify({error:"[@octokit/oauth-app] request error"})}}const{searchParams}=new URL(request.url,"http://localhost"),query=Object.fromEntries(searchParams),headers=request.headers;try{if(route===routes.getLogin){const{url}=app.getWebFlowAuthorizationUrl({state:query.state,scopes:query.scopes?query.scopes.split(","):void 0,allowSignup:query.allowSignup?"true"===query.allowSignup:void 0,redirectUrl:query.redirectUrl});return{status:302,headers:{location:url}}}if(route===routes.getCallback){if(query.error)throw new Error(`[@octokit/oauth-app] ${query.error} ${query.error_description}`);if(!query.code)throw new Error('[@octokit/oauth-app] "code" parameter is required');const{authentication:{token:token2}}=await app.createToken({code:query.code});return{status:200,headers:{"content-type":"text/html"},text:`<h1>Token created successfully</h1>\n\n<p>Your token is: <strong>${token2}</strong>. Copy it now as it cannot be shown again.</p>`}}if(route===routes.createToken){const{code,redirectUrl}=json;if(!code)throw new Error('[@octokit/oauth-app] "code" parameter is required');const result=await app.createToken({code,redirectUrl});return delete result.authentication.clientSecret,{status:201,headers:{"content-type":"application/json","access-control-allow-origin":"*"},text:JSON.stringify(result)}}if(route===routes.getToken){const token2=headers.authorization?.substr(6);if(!token2)throw new Error('[@octokit/oauth-app] "Authorization" header is required');const result=await app.checkToken({token:token2});return delete result.authentication.clientSecret,{status:200,headers:{"content-type":"application/json","access-control-allow-origin":"*"},text:JSON.stringify(result)}}if(route===routes.patchToken){const token2=headers.authorization?.substr(6);if(!token2)throw new Error('[@octokit/oauth-app] "Authorization" header is required');const result=await app.resetToken({token:token2});return delete result.authentication.clientSecret,{status:200,headers:{"content-type":"application/json","access-control-allow-origin":"*"},text:JSON.stringify(result)}}if(route===routes.patchRefreshToken){const token2=headers.authorization?.substr(6);if(!token2)throw new Error('[@octokit/oauth-app] "Authorization" header is required');const{refreshToken:refreshToken2}=json;if(!refreshToken2)throw new Error("[@octokit/oauth-app] refreshToken must be sent in request body");const result=await app.refreshToken({refreshToken:refreshToken2});return delete result.authentication.clientSecret,{status:200,headers:{"content-type":"application/json","access-control-allow-origin":"*"},text:JSON.stringify(result)}}if(route===routes.scopeToken){const token2=headers.authorization?.substr(6);if(!token2)throw new Error('[@octokit/oauth-app] "Authorization" header is required');const result=await app.scopeToken({token:token2,...json});return delete result.authentication.clientSecret,{status:200,headers:{"content-type":"application/json","access-control-allow-origin":"*"},text:JSON.stringify(result)}}if(route===routes.deleteToken){const token2=headers.authorization?.substr(6);if(!token2)throw new Error('[@octokit/oauth-app] "Authorization" header is required');return await app.deleteToken({token:token2}),{status:204,headers:{"access-control-allow-origin":"*"}}}const token=headers.authorization?.substr(6);if(!token)throw new Error('[@octokit/oauth-app] "Authorization" header is required');return await app.deleteAuthorization({token}),{status:204,headers:{"access-control-allow-origin":"*"}}}catch(error){return{status:400,headers:{"content-type":"application/json","access-control-allow-origin":"*"},text:JSON.stringify({error:error.message})}}}function sendResponse(octokitResponse,response){response.writeHead(octokitResponse.status,octokitResponse.headers),response.end(octokitResponse.text)}function createNodeMiddleware(app,options={}){return async function(request,response,next){const octokitRequest=await function parseRequest(request){const{method,url,headers}=request;return{method,url,headers,text:async function text(){return await new Promise(((resolve,reject)=>{let bodyChunks=[];request.on("error",reject).on("data",(chunk=>bodyChunks.push(chunk))).on("end",(()=>resolve(Buffer.concat(bodyChunks).toString())))}))}}}(request),octokitResponse=await handleRequest(app,options,octokitRequest);return octokitResponse?(sendResponse(octokitResponse,response),!0):(next?.(),!1)}}function createWebWorkerHandler(app,options={}){return async function(request){const octokitRequest=await function parseRequest2(request){const headers=Object.fromEntries(request.headers.entries());return{method:request.method,url:request.url,headers,text:()=>request.text()}}(request),octokitResponse=await handleRequest(app,options,octokitRequest);return octokitResponse?function sendResponse2(octokitResponse){return new Response(octokitResponse.text,{status:octokitResponse.status,headers:octokitResponse.headers})}(octokitResponse):void 0}}function createAWSLambdaAPIGatewayV2Handler(app,options={}){return async function(event){const request=function parseRequest3(request){const{method}=request.requestContext.http;let url=request.rawPath;const{stage}=request.requestContext;return url.startsWith("/"+stage)&&(url=url.substring(stage.length+1)),request.rawQueryString&&(url+="?"+request.rawQueryString),{method,url,headers:request.headers,text:async()=>request.body||""}}(event),response=await handleRequest(app,options,request);return response?function sendResponse3(octokitResponse){return{statusCode:octokitResponse.status,headers:octokitResponse.headers,body:octokitResponse.text}}(response):void 0}}var OAuthApp=class{static{this.VERSION="6.0.0"}static defaults(defaults){return class extends(this){constructor(...args){super({...defaults,...args[0]})}}}constructor(options){const Octokit2=options.Octokit||OAuthAppOctokit;this.type=options.clientType||"oauth-app";const octokit=new Octokit2({authStrategy:import_auth_oauth_app.createOAuthAppAuth,auth:{clientType:this.type,clientId:options.clientId,clientSecret:options.clientSecret}}),state={clientType:this.type,clientId:options.clientId,clientSecret:options.clientSecret,defaultScopes:options.defaultScopes||[],allowSignup:options.allowSignup,baseUrl:options.baseUrl,redirectUrl:options.redirectUrl,log:options.log,Octokit:Octokit2,octokit,eventHandlers:{}};this.on=addEventHandler.bind(null,state),this.octokit=octokit,this.getUserOctokit=getUserOctokitWithState.bind(null,state),this.getWebFlowAuthorizationUrl=getWebFlowAuthorizationUrlWithState.bind(null,state),this.createToken=createTokenWithState.bind(null,state),this.checkToken=checkTokenWithState.bind(null,state),this.resetToken=resetTokenWithState.bind(null,state),this.refreshToken=refreshTokenWithState.bind(null,state),this.scopeToken=scopeTokenWithState.bind(null,state),this.deleteToken=deleteTokenWithState.bind(null,state),this.deleteAuthorization=deleteAuthorizationWithState.bind(null,state)}}},"./node_modules/@octokit/oauth-methods/dist-src/check-token.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{a:()=>checkToken});var _octokit_request__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/@octokit/request/dist-web/index.js"),btoa_lite__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/btoa-lite/btoa-browser.js"),btoa_lite__WEBPACK_IMPORTED_MODULE_0___default=__webpack_require__.n(btoa_lite__WEBPACK_IMPORTED_MODULE_0__);async function checkToken(options){const request=options.request||_octokit_request__WEBPACK_IMPORTED_MODULE_1__.request,response=await request("POST /applications/{client_id}/token",{headers:{authorization:`basic ${btoa_lite__WEBPACK_IMPORTED_MODULE_0___default()(`${options.clientId}:${options.clientSecret}`)}`},client_id:options.clientId,access_token:options.token}),authentication={clientType:options.clientType,clientId:options.clientId,clientSecret:options.clientSecret,token:options.token,scopes:response.data.scopes};return response.data.expires_at&&(authentication.expiresAt=response.data.expires_at),"github-app"===options.clientType&&delete authentication.scopes,{...response,authentication}}},"./node_modules/@octokit/oauth-methods/dist-src/create-device-code.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{T:()=>createDeviceCode});var _octokit_request__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/@octokit/request/dist-web/index.js"),_utils__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/@octokit/oauth-methods/dist-src/utils.js");async function createDeviceCode(options){const request=options.request||_octokit_request__WEBPACK_IMPORTED_MODULE_0__.request,parameters={client_id:options.clientId};return"scopes"in options&&Array.isArray(options.scopes)&&(parameters.scope=options.scopes.join(" ")),(0,_utils__WEBPACK_IMPORTED_MODULE_1__.d)(request,"POST /login/device/code",parameters)}},"./node_modules/@octokit/oauth-methods/dist-src/delete-authorization.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{s:()=>deleteAuthorization});var _octokit_request__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/@octokit/request/dist-web/index.js"),btoa_lite__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/btoa-lite/btoa-browser.js"),btoa_lite__WEBPACK_IMPORTED_MODULE_0___default=__webpack_require__.n(btoa_lite__WEBPACK_IMPORTED_MODULE_0__);async function deleteAuthorization(options){return(options.request||_octokit_request__WEBPACK_IMPORTED_MODULE_1__.request)("DELETE /applications/{client_id}/grant",{headers:{authorization:`basic ${btoa_lite__WEBPACK_IMPORTED_MODULE_0___default()(`${options.clientId}:${options.clientSecret}`)}`},client_id:options.clientId,access_token:options.token})}},"./node_modules/@octokit/oauth-methods/dist-src/delete-token.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{p:()=>deleteToken});var _octokit_request__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/@octokit/request/dist-web/index.js"),btoa_lite__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/btoa-lite/btoa-browser.js"),btoa_lite__WEBPACK_IMPORTED_MODULE_0___default=__webpack_require__.n(btoa_lite__WEBPACK_IMPORTED_MODULE_0__);async function deleteToken(options){return(options.request||_octokit_request__WEBPACK_IMPORTED_MODULE_1__.request)("DELETE /applications/{client_id}/token",{headers:{authorization:`basic ${btoa_lite__WEBPACK_IMPORTED_MODULE_0___default()(`${options.clientId}:${options.clientSecret}`)}`},client_id:options.clientId,access_token:options.token})}},"./node_modules/@octokit/oauth-methods/dist-src/exchange-device-code.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{i:()=>exchangeDeviceCode});var _octokit_request__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/@octokit/request/dist-web/index.js"),_utils__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/@octokit/oauth-methods/dist-src/utils.js");async function exchangeDeviceCode(options){const request=options.request||_octokit_request__WEBPACK_IMPORTED_MODULE_0__.request,response=await(0,_utils__WEBPACK_IMPORTED_MODULE_1__.d)(request,"POST /login/oauth/access_token",{client_id:options.clientId,device_code:options.code,grant_type:"urn:ietf:params:oauth:grant-type:device_code"}),authentication={clientType:options.clientType,clientId:options.clientId,token:response.data.access_token,scopes:response.data.scope.split(/\s+/).filter(Boolean)};if("clientSecret"in options&&(authentication.clientSecret=options.clientSecret),"github-app"===options.clientType){if("refresh_token"in response.data){const apiTimeInMs=new Date(response.headers.date).getTime();authentication.refreshToken=response.data.refresh_token,authentication.expiresAt=toTimestamp(apiTimeInMs,response.data.expires_in),authentication.refreshTokenExpiresAt=toTimestamp(apiTimeInMs,response.data.refresh_token_expires_in)}delete authentication.scopes}return{...response,authentication}}function toTimestamp(apiTimeInMs,expirationInSeconds){return new Date(apiTimeInMs+1e3*expirationInSeconds).toISOString()}},"./node_modules/@octokit/oauth-methods/dist-src/exchange-web-flow-code.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{y:()=>exchangeWebFlowCode});var _octokit_request__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/@octokit/request/dist-web/index.js"),_utils__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/@octokit/oauth-methods/dist-src/utils.js");async function exchangeWebFlowCode(options){const request=options.request||_octokit_request__WEBPACK_IMPORTED_MODULE_0__.request,response=await(0,_utils__WEBPACK_IMPORTED_MODULE_1__.d)(request,"POST /login/oauth/access_token",{client_id:options.clientId,client_secret:options.clientSecret,code:options.code,redirect_uri:options.redirectUrl}),authentication={clientType:options.clientType,clientId:options.clientId,clientSecret:options.clientSecret,token:response.data.access_token,scopes:response.data.scope.split(/\s+/).filter(Boolean)};if("github-app"===options.clientType){if("refresh_token"in response.data){const apiTimeInMs=new Date(response.headers.date).getTime();authentication.refreshToken=response.data.refresh_token,authentication.expiresAt=toTimestamp(apiTimeInMs,response.data.expires_in),authentication.refreshTokenExpiresAt=toTimestamp(apiTimeInMs,response.data.refresh_token_expires_in)}delete authentication.scopes}return{...response,authentication}}function toTimestamp(apiTimeInMs,expirationInSeconds){return new Date(apiTimeInMs+1e3*expirationInSeconds).toISOString()}},"./node_modules/@octokit/oauth-methods/dist-src/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{VERSION:()=>VERSION,checkToken:()=>check_token.a,createDeviceCode:()=>create_device_code.T,deleteAuthorization:()=>delete_authorization.s,deleteToken:()=>delete_token.p,exchangeDeviceCode:()=>exchange_device_code.i,exchangeWebFlowCode:()=>exchange_web_flow_code.y,getWebFlowAuthorizationUrl:()=>getWebFlowAuthorizationUrl,refreshToken:()=>refresh_token.g,resetToken:()=>reset_token.E,scopeToken:()=>scopeToken});const VERSION="4.0.1";function oauthAuthorizationUrl(options){const clientType=options.clientType||"oauth-app",baseUrl=options.baseUrl||"https://github.com",result={clientType,allowSignup:!1!==options.allowSignup,clientId:options.clientId,login:options.login||null,redirectUrl:options.redirectUrl||null,state:options.state||Math.random().toString(36).substr(2),url:""};if("oauth-app"===clientType){const scopes="scopes"in options?options.scopes:[];result.scopes="string"==typeof scopes?scopes.split(/[,\s]+/).filter(Boolean):scopes}return result.url=function urlBuilderAuthorize(base,options){const map={allowSignup:"allow_signup",clientId:"client_id",login:"login",redirectUrl:"redirect_uri",scopes:"scope",state:"state"};let url=base;return Object.keys(map).filter((k=>null!==options[k])).filter((k=>"scopes"!==k||"github-app"!==options.clientType&&(!Array.isArray(options[k])||options[k].length>0))).map((key=>[map[key],`${options[key]}`])).forEach((([key,value],index)=>{url+=0===index?"?":"&",url+=`${key}=${encodeURIComponent(value)}`})),url}(`${baseUrl}/login/oauth/authorize`,result),result}var dist_web=__webpack_require__("./node_modules/@octokit/request/dist-web/index.js"),utils=__webpack_require__("./node_modules/@octokit/oauth-methods/dist-src/utils.js");function getWebFlowAuthorizationUrl({request=dist_web.request,...options}){return oauthAuthorizationUrl({...options,baseUrl:(0,utils.l)(request)})}var exchange_web_flow_code=__webpack_require__("./node_modules/@octokit/oauth-methods/dist-src/exchange-web-flow-code.js"),create_device_code=__webpack_require__("./node_modules/@octokit/oauth-methods/dist-src/create-device-code.js"),exchange_device_code=__webpack_require__("./node_modules/@octokit/oauth-methods/dist-src/exchange-device-code.js"),check_token=__webpack_require__("./node_modules/@octokit/oauth-methods/dist-src/check-token.js"),refresh_token=__webpack_require__("./node_modules/@octokit/oauth-methods/dist-src/refresh-token.js"),btoa_browser=__webpack_require__("./node_modules/btoa-lite/btoa-browser.js"),btoa_browser_default=__webpack_require__.n(btoa_browser);async function scopeToken(options){const{request:optionsRequest,clientType,clientId,clientSecret,token,...requestOptions}=options,request=optionsRequest||dist_web.request,response=await request("POST /applications/{client_id}/token/scoped",{headers:{authorization:`basic ${btoa_browser_default()(`${clientId}:${clientSecret}`)}`},client_id:clientId,access_token:token,...requestOptions}),authentication=Object.assign({clientType,clientId,clientSecret,token:response.data.token},response.data.expires_at?{expiresAt:response.data.expires_at}:{});return{...response,authentication}}var reset_token=__webpack_require__("./node_modules/@octokit/oauth-methods/dist-src/reset-token.js"),delete_token=__webpack_require__("./node_modules/@octokit/oauth-methods/dist-src/delete-token.js"),delete_authorization=__webpack_require__("./node_modules/@octokit/oauth-methods/dist-src/delete-authorization.js")},"./node_modules/@octokit/oauth-methods/dist-src/refresh-token.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{g:()=>refreshToken});var _octokit_request__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/@octokit/request/dist-web/index.js"),_utils__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/@octokit/oauth-methods/dist-src/utils.js");async function refreshToken(options){const request=options.request||_octokit_request__WEBPACK_IMPORTED_MODULE_0__.request,response=await(0,_utils__WEBPACK_IMPORTED_MODULE_1__.d)(request,"POST /login/oauth/access_token",{client_id:options.clientId,client_secret:options.clientSecret,grant_type:"refresh_token",refresh_token:options.refreshToken}),apiTimeInMs=new Date(response.headers.date).getTime(),authentication={clientType:"github-app",clientId:options.clientId,clientSecret:options.clientSecret,token:response.data.access_token,refreshToken:response.data.refresh_token,expiresAt:toTimestamp(apiTimeInMs,response.data.expires_in),refreshTokenExpiresAt:toTimestamp(apiTimeInMs,response.data.refresh_token_expires_in)};return{...response,authentication}}function toTimestamp(apiTimeInMs,expirationInSeconds){return new Date(apiTimeInMs+1e3*expirationInSeconds).toISOString()}},"./node_modules/@octokit/oauth-methods/dist-src/reset-token.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{E:()=>resetToken});var _octokit_request__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/@octokit/request/dist-web/index.js"),btoa_lite__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/btoa-lite/btoa-browser.js"),btoa_lite__WEBPACK_IMPORTED_MODULE_0___default=__webpack_require__.n(btoa_lite__WEBPACK_IMPORTED_MODULE_0__);async function resetToken(options){const request=options.request||_octokit_request__WEBPACK_IMPORTED_MODULE_1__.request,auth=btoa_lite__WEBPACK_IMPORTED_MODULE_0___default()(`${options.clientId}:${options.clientSecret}`),response=await request("PATCH /applications/{client_id}/token",{headers:{authorization:`basic ${auth}`},client_id:options.clientId,access_token:options.token}),authentication={clientType:options.clientType,clientId:options.clientId,clientSecret:options.clientSecret,token:response.data.token,scopes:response.data.scopes};return response.data.expires_at&&(authentication.expiresAt=response.data.expires_at),"github-app"===options.clientType&&delete authentication.scopes,{...response,authentication}}},"./node_modules/@octokit/oauth-methods/dist-src/utils.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{d:()=>oauthRequest,l:()=>requestToOAuthBaseUrl});var _octokit_request_error__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/@octokit/request-error/dist-web/index.js");function requestToOAuthBaseUrl(request){const endpointDefaults=request.endpoint.DEFAULTS;return/^https:\/\/(api\.)?github\.com$/.test(endpointDefaults.baseUrl)?"https://github.com":endpointDefaults.baseUrl.replace("/api/v3","")}async function oauthRequest(request,route,parameters){const withOAuthParameters={baseUrl:requestToOAuthBaseUrl(request),headers:{accept:"application/json"},...parameters},response=await request(route,withOAuthParameters);if("error"in response.data){const error=new _octokit_request_error__WEBPACK_IMPORTED_MODULE_0__.RequestError(`${response.data.error_description} (${response.data.error}, ${response.data.error_uri})`,400,{request:request.endpoint.merge(route,withOAuthParameters),headers:response.headers});throw error.response=response,error}return response}},"./node_modules/@octokit/request-error/dist-web/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{RequestError:()=>RequestError});var deprecation__WEBPACK_IMPORTED_MODULE_1__=__webpack_require__("./node_modules/deprecation/dist-web/index.js"),once__WEBPACK_IMPORTED_MODULE_0__=__webpack_require__("./node_modules/once/once.js"),once__WEBPACK_IMPORTED_MODULE_0___default=__webpack_require__.n(once__WEBPACK_IMPORTED_MODULE_0__),console=__webpack_require__("./node_modules/console-browserify/index.js"),logOnceCode=once__WEBPACK_IMPORTED_MODULE_0___default()((deprecation=>console.warn(deprecation))),logOnceHeaders=once__WEBPACK_IMPORTED_MODULE_0___default()((deprecation=>console.warn(deprecation))),RequestError=class extends Error{constructor(message,statusCode,options){let headers;super(message),Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor),this.name="HttpError",this.status=statusCode,"headers"in options&&void 0!==options.headers&&(headers=options.headers),"response"in options&&(this.response=options.response,headers=options.response.headers);const requestCopy=Object.assign({},options.request);options.request.headers.authorization&&(requestCopy.headers=Object.assign({},options.request.headers,{authorization:options.request.headers.authorization.replace(/ .*$/," [REDACTED]")})),requestCopy.url=requestCopy.url.replace(/\bclient_secret=\w+/g,"client_secret=[REDACTED]").replace(/\baccess_token=\w+/g,"access_token=[REDACTED]"),this.request=requestCopy,Object.defineProperty(this,"code",{get:()=>(logOnceCode(new deprecation__WEBPACK_IMPORTED_MODULE_1__.Deprecation("[@octokit/request-error] `error.code` is deprecated, use `error.status`.")),statusCode)}),Object.defineProperty(this,"headers",{get:()=>(logOnceHeaders(new deprecation__WEBPACK_IMPORTED_MODULE_1__.Deprecation("[@octokit/request-error] `error.headers` is deprecated, use `error.response.headers`.")),headers||{})})}}},"./node_modules/@octokit/request/dist-web/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{request:()=>request});var dist_web=__webpack_require__("./node_modules/universal-user-agent/dist-web/index.js"),userAgent=`octokit-endpoint.js/9.0.4 ${(0,dist_web.getUserAgent)()}`;function mergeDeep(defaults,options){const result=Object.assign({},defaults);return Object.keys(options).forEach((key=>{!function isPlainObject(value){if("object"!=typeof value||null===value)return!1;if("[object Object]"!==Object.prototype.toString.call(value))return!1;const proto=Object.getPrototypeOf(value);if(null===proto)return!0;const Ctor=Object.prototype.hasOwnProperty.call(proto,"constructor")&&proto.constructor;return"function"==typeof Ctor&&Ctor instanceof Ctor&&Function.prototype.call(Ctor)===Function.prototype.call(value)}(options[key])?Object.assign(result,{[key]:options[key]}):key in defaults?result[key]=mergeDeep(defaults[key],options[key]):Object.assign(result,{[key]:options[key]})})),result}function removeUndefinedProperties(obj){for(const key in obj)void 0===obj[key]&&delete obj[key];return obj}function merge(defaults,route,options){if("string"==typeof route){let[method,url]=route.split(" ");options=Object.assign(url?{method,url}:{url:method},options)}else options=Object.assign({},route);options.headers=function lowercaseKeys(object){return object?Object.keys(object).reduce(((newObj,key)=>(newObj[key.toLowerCase()]=object[key],newObj)),{}):{}}(options.headers),removeUndefinedProperties(options),removeUndefinedProperties(options.headers);const mergedOptions=mergeDeep(defaults||{},options);return"/graphql"===options.url&&(defaults&&defaults.mediaType.previews?.length&&(mergedOptions.mediaType.previews=defaults.mediaType.previews.filter((preview=>!mergedOptions.mediaType.previews.includes(preview))).concat(mergedOptions.mediaType.previews)),mergedOptions.mediaType.previews=(mergedOptions.mediaType.previews||[]).map((preview=>preview.replace(/-preview/,"")))),mergedOptions}var urlVariableRegex=/\{[^}]+\}/g;function removeNonChars(variableName){return variableName.replace(/^\W+|\W+$/g,"").split(/,/)}function omit(object,keysToOmit){const result={__proto__:null};for(const key of Object.keys(object))-1===keysToOmit.indexOf(key)&&(result[key]=object[key]);return result}function encodeReserved(str){return str.split(/(%[0-9A-Fa-f]{2})/g).map((function(part){return/%[0-9A-Fa-f]/.test(part)||(part=encodeURI(part).replace(/%5B/g,"[").replace(/%5D/g,"]")),part})).join("")}function encodeUnreserved(str){return encodeURIComponent(str).replace(/[!'()*]/g,(function(c){return"%"+c.charCodeAt(0).toString(16).toUpperCase()}))}function encodeValue(operator,value,key){return value="+"===operator||"#"===operator?encodeReserved(value):encodeUnreserved(value),key?encodeUnreserved(key)+"="+value:value}function isDefined(value){return null!=value}function isKeyOperator(operator){return";"===operator||"&"===operator||"?"===operator}function expand(template,context){var operators=["+","#",".","/",";","?","&"];return template=template.replace(/\{([^\{\}]+)\}|([^\{\}]+)/g,(function(_,expression,literal){if(expression){let operator="";const values=[];if(-1!==operators.indexOf(expression.charAt(0))&&(operator=expression.charAt(0),expression=expression.substr(1)),expression.split(/,/g).forEach((function(variable){var tmp=/([^:\*]*)(?::(\d+)|(\*))?/.exec(variable);values.push(function getValues(context,operator,key,modifier){var value=context[key],result=[];if(isDefined(value)&&""!==value)if("string"==typeof value||"number"==typeof value||"boolean"==typeof value)value=value.toString(),modifier&&"*"!==modifier&&(value=value.substring(0,parseInt(modifier,10))),result.push(encodeValue(operator,value,isKeyOperator(operator)?key:""));else if("*"===modifier)Array.isArray(value)?value.filter(isDefined).forEach((function(value2){result.push(encodeValue(operator,value2,isKeyOperator(operator)?key:""))})):Object.keys(value).forEach((function(k){isDefined(value[k])&&result.push(encodeValue(operator,value[k],k))}));else{const tmp=[];Array.isArray(value)?value.filter(isDefined).forEach((function(value2){tmp.push(encodeValue(operator,value2))})):Object.keys(value).forEach((function(k){isDefined(value[k])&&(tmp.push(encodeUnreserved(k)),tmp.push(encodeValue(operator,value[k].toString())))})),isKeyOperator(operator)?result.push(encodeUnreserved(key)+"="+tmp.join(",")):0!==tmp.length&&result.push(tmp.join(","))}else";"===operator?isDefined(value)&&result.push(encodeUnreserved(key)):""!==value||"&"!==operator&&"?"!==operator?""===value&&result.push(""):result.push(encodeUnreserved(key)+"=");return result}(context,operator,tmp[1],tmp[2]||tmp[3]))})),operator&&"+"!==operator){var separator=",";return"?"===operator?separator="&":"#"!==operator&&(separator=operator),(0!==values.length?operator:"")+values.join(separator)}return values.join(",")}return encodeReserved(literal)})),"/"===template?template:template.replace(/\/$/,"")}function parse(options){let body,method=options.method.toUpperCase(),url=(options.url||"/").replace(/:([a-z]\w+)/g,"{$1}"),headers=Object.assign({},options.headers),parameters=omit(options,["method","baseUrl","url","headers","request","mediaType"]);const urlVariableNames=function extractUrlVariableNames(url){const matches=url.match(urlVariableRegex);return matches?matches.map(removeNonChars).reduce(((a,b)=>a.concat(b)),[]):[]}(url);url=function parseUrl(template){return{expand:expand.bind(null,template)}}(url).expand(parameters),/^http/.test(url)||(url=options.baseUrl+url);const remainingParameters=omit(parameters,Object.keys(options).filter((option=>urlVariableNames.includes(option))).concat("baseUrl"));if(!/application\/octet-stream/i.test(headers.accept)&&(options.mediaType.format&&(headers.accept=headers.accept.split(/,/).map((format=>format.replace(/application\/vnd(\.\w+)(\.v3)?(\.\w+)?(\+json)?$/,`application/vnd$1$2.${options.mediaType.format}`))).join(",")),url.endsWith("/graphql")&&options.mediaType.previews?.length)){const previewsFromAcceptHeader=headers.accept.match(/[\w-]+(?=-preview)/g)||[];headers.accept=previewsFromAcceptHeader.concat(options.mediaType.previews).map((preview=>`application/vnd.github.${preview}-preview${options.mediaType.format?`.${options.mediaType.format}`:"+json"}`)).join(",")}return["GET","HEAD"].includes(method)?url=function addQueryParameters(url,parameters){const separator=/\?/.test(url)?"&":"?",names=Object.keys(parameters);return 0===names.length?url:url+separator+names.map((name=>"q"===name?"q="+parameters.q.split("+").map(encodeURIComponent).join("+"):`${name}=${encodeURIComponent(parameters[name])}`)).join("&")}(url,remainingParameters):"data"in remainingParameters?body=remainingParameters.data:Object.keys(remainingParameters).length&&(body=remainingParameters),headers["content-type"]||void 0===body||(headers["content-type"]="application/json; charset=utf-8"),["PATCH","PUT"].includes(method)&&void 0===body&&(body=""),Object.assign({method,url,headers},void 0!==body?{body}:null,options.request?{request:options.request}:null)}function endpointWithDefaults(defaults,route,options){return parse(merge(defaults,route,options))}var endpoint=function withDefaults(oldDefaults,newDefaults){const DEFAULTS2=merge(oldDefaults,newDefaults),endpoint2=endpointWithDefaults.bind(null,DEFAULTS2);return Object.assign(endpoint2,{DEFAULTS:DEFAULTS2,defaults:withDefaults.bind(null,DEFAULTS2),merge:merge.bind(null,DEFAULTS2),parse})}(null,{method:"GET",baseUrl:"https://api.github.com",headers:{accept:"application/vnd.github.v3+json","user-agent":userAgent},mediaType:{format:""}}),request_error_dist_web=__webpack_require__("./node_modules/@octokit/request-error/dist-web/index.js"),console=__webpack_require__("./node_modules/console-browserify/index.js");function fetchWrapper(requestOptions){const log=requestOptions.request&&requestOptions.request.log?requestOptions.request.log:console,parseSuccessResponseBody=!1!==requestOptions.request?.parseSuccessResponseBody;(function dist_web_isPlainObject(value){if("object"!=typeof value||null===value)return!1;if("[object Object]"!==Object.prototype.toString.call(value))return!1;const proto=Object.getPrototypeOf(value);if(null===proto)return!0;const Ctor=Object.prototype.hasOwnProperty.call(proto,"constructor")&&proto.constructor;return"function"==typeof Ctor&&Ctor instanceof Ctor&&Function.prototype.call(Ctor)===Function.prototype.call(value)}(requestOptions.body)||Array.isArray(requestOptions.body))&&(requestOptions.body=JSON.stringify(requestOptions.body));let status,url,headers={},{fetch}=globalThis;if(requestOptions.request?.fetch&&(fetch=requestOptions.request.fetch),!fetch)throw new Error("fetch is not set. Please pass a fetch implementation as new Octokit({ request: { fetch }}). Learn more at https://github.com/octokit/octokit.js/#fetch-missing");return fetch(requestOptions.url,{method:requestOptions.method,body:requestOptions.body,headers:requestOptions.headers,signal:requestOptions.request?.signal,...requestOptions.body&&{duplex:"half"}}).then((async response=>{url=response.url,status=response.status;for(const keyAndValue of response.headers)headers[keyAndValue[0]]=keyAndValue[1];if("deprecation"in headers){const matches=headers.link&&headers.link.match(/<([^>]+)>; rel="deprecation"/),deprecationLink=matches&&matches.pop();log.warn(`[@octokit/request] "${requestOptions.method} ${requestOptions.url}" is deprecated. It is scheduled to be removed on ${headers.sunset}${deprecationLink?`. See ${deprecationLink}`:""}`)}if(204!==status&&205!==status){if("HEAD"===requestOptions.method){if(status<400)return;throw new request_error_dist_web.RequestError(response.statusText,status,{response:{url,status,headers,data:void 0},request:requestOptions})}if(304===status)throw new request_error_dist_web.RequestError("Not modified",status,{response:{url,status,headers,data:await getResponseData(response)},request:requestOptions});if(status>=400){const data=await getResponseData(response),error=new request_error_dist_web.RequestError(function toErrorMessage(data){if("string"==typeof data)return data;if("message"in data)return Array.isArray(data.errors)?`${data.message}: ${data.errors.map(JSON.stringify).join(", ")}`:data.message;return`Unknown error: ${JSON.stringify(data)}`}(data),status,{response:{url,status,headers,data},request:requestOptions});throw error}return parseSuccessResponseBody?await getResponseData(response):response.body}})).then((data=>({status,url,headers,data}))).catch((error=>{if(error instanceof request_error_dist_web.RequestError)throw error;if("AbortError"===error.name)throw error;let message=error.message;throw"TypeError"===error.name&&"cause"in error&&(error.cause instanceof Error?message=error.cause.message:"string"==typeof error.cause&&(message=error.cause)),new request_error_dist_web.RequestError(message,500,{request:requestOptions})}))}async function getResponseData(response){const contentType=response.headers.get("content-type");return/application\/json/.test(contentType)?response.json().catch((()=>response.text())).catch((()=>"")):!contentType||/^text\/|charset=utf-8$/.test(contentType)?response.text():function getBufferResponse(response){return response.arrayBuffer()}(response)}var request=function dist_web_withDefaults(oldEndpoint,newDefaults){const endpoint2=oldEndpoint.defaults(newDefaults);return Object.assign((function(route,parameters){const endpointOptions=endpoint2.merge(route,parameters);if(!endpointOptions.request||!endpointOptions.request.hook)return fetchWrapper(endpoint2.parse(endpointOptions));const request2=(route2,parameters2)=>fetchWrapper(endpoint2.parse(endpoint2.merge(route2,parameters2)));return Object.assign(request2,{endpoint:endpoint2,defaults:dist_web_withDefaults.bind(null,endpoint2)}),endpointOptions.request.hook(request2,endpointOptions)}),{endpoint:endpoint2,defaults:dist_web_withDefaults.bind(null,endpoint2)})}(endpoint,{headers:{"user-agent":`octokit-request.js/8.1.6 ${(0,dist_web.getUserAgent)()}`}})},"./node_modules/aggregate-error/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";const indentString=__webpack_require__("./node_modules/indent-string/index.js"),cleanStack=__webpack_require__("./node_modules/clean-stack/index.js");class AggregateError extends Error{constructor(errors){if(!Array.isArray(errors))throw new TypeError("Expected input to be an Array, got "+typeof errors);let message=(errors=[...errors].map((error=>error instanceof Error?error:null!==error&&"object"==typeof error?Object.assign(new Error(error.message),error):new Error(error)))).map((error=>"string"==typeof error.stack?cleanStack(error.stack).replace(/\s+at .*aggregate-error\/index.js:\d+:\d+\)?/g,""):String(error))).join("\n");message="\n"+indentString(message,4),super(message),this.name="AggregateError",Object.defineProperty(this,"_errors",{value:errors})}*[Symbol.iterator](){for(const error of this._errors)yield error}}module.exports=AggregateError},"./node_modules/before-after-hook/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{var console=__webpack_require__("./node_modules/console-browserify/index.js"),register=__webpack_require__("./node_modules/before-after-hook/lib/register.js"),addHook=__webpack_require__("./node_modules/before-after-hook/lib/add.js"),removeHook=__webpack_require__("./node_modules/before-after-hook/lib/remove.js"),bind=Function.bind,bindable=bind.bind(bind);function bindApi(hook,state,name){var removeHookRef=bindable(removeHook,null).apply(null,name?[state,name]:[state]);hook.api={remove:removeHookRef},hook.remove=removeHookRef,["before","error","after","wrap"].forEach((function(kind){var args=name?[state,kind,name]:[state,kind];hook[kind]=hook.api[kind]=bindable(addHook,null).apply(null,args)}))}function HookCollection(){var state={registry:{}},hook=register.bind(null,state);return bindApi(hook,state),hook}var collectionHookDeprecationMessageDisplayed=!1;function Hook(){return collectionHookDeprecationMessageDisplayed||(console.warn('[before-after-hook]: "Hook()" repurposing warning, use "Hook.Collection()". Read more: https://git.io/upgrade-before-after-hook-to-1.4'),collectionHookDeprecationMessageDisplayed=!0),HookCollection()}Hook.Singular=function HookSingular(){var singularHookState={registry:{}},singularHook=register.bind(null,singularHookState,"h");return bindApi(singularHook,singularHookState,"h"),singularHook}.bind(),Hook.Collection=HookCollection.bind(),module.exports=Hook,module.exports.Hook=Hook,module.exports.Singular=Hook.Singular,module.exports.Collection=Hook.Collection},"./node_modules/before-after-hook/lib/add.js":module=>{module.exports=function addHook(state,kind,name,hook){var orig=hook;state.registry[name]||(state.registry[name]=[]);"before"===kind&&(hook=function(method,options){return Promise.resolve().then(orig.bind(null,options)).then(method.bind(null,options))});"after"===kind&&(hook=function(method,options){var result;return Promise.resolve().then(method.bind(null,options)).then((function(result_){return orig(result=result_,options)})).then((function(){return result}))});"error"===kind&&(hook=function(method,options){return Promise.resolve().then(method.bind(null,options)).catch((function(error){return orig(error,options)}))});state.registry[name].push({hook,orig})}},"./node_modules/before-after-hook/lib/register.js":module=>{module.exports=function register(state,name,method,options){if("function"!=typeof method)throw new Error("method for before hook must be a function");options||(options={});if(Array.isArray(name))return name.reverse().reduce((function(callback,name){return register.bind(null,state,name,callback,options)}),method)();return Promise.resolve().then((function(){return state.registry[name]?state.registry[name].reduce((function(method,registered){return registered.hook.bind(null,method,options)}),method)():method(options)}))}},"./node_modules/before-after-hook/lib/remove.js":module=>{module.exports=function removeHook(state,name,method){if(!state.registry[name])return;var index=state.registry[name].map((function(registered){return registered.orig})).indexOf(method);if(-1===index)return;state.registry[name].splice(index,1)}},"./node_modules/bottleneck/light.js":function(module,__unused_webpack_exports,__webpack_require__){var console=__webpack_require__("./node_modules/console-browserify/index.js");module.exports=function(){"use strict";var commonjsGlobal="undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:void 0!==__webpack_require__.g?__webpack_require__.g:"undefined"!=typeof self?self:{};function getCjsExportFromNamespace(n){return n&&n.default||n}var DLList$1,Events$1,parser={load:function(received,defaults,onto={}){var k,ref,v;for(k in defaults)v=defaults[k],onto[k]=null!=(ref=received[k])?ref:v;return onto},overwrite:function(received,defaults,onto={}){var k,v;for(k in received)v=received[k],void 0!==defaults[k]&&(onto[k]=v);return onto}},DLList_1=class DLList{constructor(incr,decr){this.incr=incr,this.decr=decr,this._first=null,this._last=null,this.length=0}push(value){var node;this.length++,"function"==typeof this.incr&&this.incr(),node={value,prev:this._last,next:null},null!=this._last?(this._last.next=node,this._last=node):this._first=this._last=node}shift(){var value;if(null!=this._first)return this.length--,"function"==typeof this.decr&&this.decr(),value=this._first.value,null!=(this._first=this._first.next)?this._first.prev=null:this._last=null,value}first(){if(null!=this._first)return this._first.value}getArray(){var node,ref,results;for(node=this._first,results=[];null!=node;)results.push((ref=node,node=node.next,ref.value));return results}forEachShift(cb){var node;for(node=this.shift();null!=node;)cb(node),node=this.shift()}debug(){var node,ref,ref1,ref2,results;for(node=this._first,results=[];null!=node;)results.push((ref=node,node=node.next,{value:ref.value,prev:null!=(ref1=ref.prev)?ref1.value:void 0,next:null!=(ref2=ref.next)?ref2.value:void 0}));return results}},Events_1=class Events{constructor(instance){if(this.instance=instance,this._events={},null!=this.instance.on||null!=this.instance.once||null!=this.instance.removeAllListeners)throw new Error("An Emitter already exists for this object");this.instance.on=(name,cb)=>this._addListener(name,"many",cb),this.instance.once=(name,cb)=>this._addListener(name,"once",cb),this.instance.removeAllListeners=(name=null)=>null!=name?delete this._events[name]:this._events={}}_addListener(name,status,cb){var base;return null==(base=this._events)[name]&&(base[name]=[]),this._events[name].push({cb,status}),this.instance}listenerCount(name){return null!=this._events[name]?this._events[name].length:0}async trigger(name,...args){var e,promises;try{if("debug"!==name&&this.trigger("debug",`Event triggered: ${name}`,args),null==this._events[name])return;return this._events[name]=this._events[name].filter((function(listener){return"none"!==listener.status})),promises=this._events[name].map((async listener=>{var e,returned;if("none"!==listener.status){"once"===listener.status&&(listener.status="none");try{return"function"==typeof(null!=(returned="function"==typeof listener.cb?listener.cb(...args):void 0)?returned.then:void 0)?await returned:returned}catch(error){return e=error,this.trigger("error",e),null}}})),(await Promise.all(promises)).find((function(x){return null!=x}))}catch(error){return e=error,this.trigger("error",e),null}}};DLList$1=DLList_1,Events$1=Events_1;var BottleneckError$1,DEFAULT_PRIORITY,NUM_PRIORITIES,parser$1,Queues_1=class Queues{constructor(num_priorities){this.Events=new Events$1(this),this._length=0,this._lists=function(){var j,ref,results;for(results=[],j=1,ref=num_priorities;1<=ref?j<=ref:j>=ref;1<=ref?++j:--j)results.push(new DLList$1((()=>this.incr()),(()=>this.decr())));return results}.call(this)}incr(){if(0==this._length++)return this.Events.trigger("leftzero")}decr(){if(0==--this._length)return this.Events.trigger("zero")}push(job){return this._lists[job.options.priority].push(job)}queued(priority){return null!=priority?this._lists[priority].length:this._length}shiftAll(fn){return this._lists.forEach((function(list){return list.forEachShift(fn)}))}getFirst(arr=this._lists){var j,len,list;for(j=0,len=arr.length;j<len;j++)if((list=arr[j]).length>0)return list;return[]}shiftLastFrom(priority){return this.getFirst(this._lists.slice(priority).reverse()).shift()}},BottleneckError_1=class BottleneckError extends Error{};NUM_PRIORITIES=10,DEFAULT_PRIORITY=5,parser$1=parser,BottleneckError$1=BottleneckError_1;var BottleneckError$2,parser$2,Job_1=class Job{constructor(task,args,options,jobDefaults,rejectOnDrop,Events,_states,Promise){this.task=task,this.args=args,this.rejectOnDrop=rejectOnDrop,this.Events=Events,this._states=_states,this.Promise=Promise,this.options=parser$1.load(options,jobDefaults),this.options.priority=this._sanitizePriority(this.options.priority),this.options.id===jobDefaults.id&&(this.options.id=`${this.options.id}-${this._randomIndex()}`),this.promise=new this.Promise(((_resolve,_reject)=>{this._resolve=_resolve,this._reject=_reject})),this.retryCount=0}_sanitizePriority(priority){var sProperty;return(sProperty=~~priority!==priority?DEFAULT_PRIORITY:priority)<0?0:sProperty>NUM_PRIORITIES-1?NUM_PRIORITIES-1:sProperty}_randomIndex(){return Math.random().toString(36).slice(2)}doDrop({error,message="This job has been dropped by Bottleneck"}={}){return!!this._states.remove(this.options.id)&&(this.rejectOnDrop&&this._reject(null!=error?error:new BottleneckError$1(message)),this.Events.trigger("dropped",{args:this.args,options:this.options,task:this.task,promise:this.promise}),!0)}_assertStatus(expected){var status;if((status=this._states.jobStatus(this.options.id))!==expected&&("DONE"!==expected||null!==status))throw new BottleneckError$1(`Invalid job status ${status}, expected ${expected}. Please open an issue at https://github.com/SGrondin/bottleneck/issues`)}doReceive(){return this._states.start(this.options.id),this.Events.trigger("received",{args:this.args,options:this.options})}doQueue(reachedHWM,blocked){return this._assertStatus("RECEIVED"),this._states.next(this.options.id),this.Events.trigger("queued",{args:this.args,options:this.options,reachedHWM,blocked})}doRun(){return 0===this.retryCount?(this._assertStatus("QUEUED"),this._states.next(this.options.id)):this._assertStatus("EXECUTING"),this.Events.trigger("scheduled",{args:this.args,options:this.options})}async doExecute(chained,clearGlobalState,run,free){var error,eventInfo,passed;0===this.retryCount?(this._assertStatus("RUNNING"),this._states.next(this.options.id)):this._assertStatus("EXECUTING"),eventInfo={args:this.args,options:this.options,retryCount:this.retryCount},this.Events.trigger("executing",eventInfo);try{if(passed=await(null!=chained?chained.schedule(this.options,this.task,...this.args):this.task(...this.args)),clearGlobalState())return this.doDone(eventInfo),await free(this.options,eventInfo),this._assertStatus("DONE"),this._resolve(passed)}catch(error1){return error=error1,this._onFailure(error,eventInfo,clearGlobalState,run,free)}}doExpire(clearGlobalState,run,free){var error,eventInfo;return this._states.jobStatus("RUNNING"===this.options.id)&&this._states.next(this.options.id),this._assertStatus("EXECUTING"),eventInfo={args:this.args,options:this.options,retryCount:this.retryCount},error=new BottleneckError$1(`This job timed out after ${this.options.expiration} ms.`),this._onFailure(error,eventInfo,clearGlobalState,run,free)}async _onFailure(error,eventInfo,clearGlobalState,run,free){var retry,retryAfter;if(clearGlobalState())return null!=(retry=await this.Events.trigger("failed",error,eventInfo))?(retryAfter=~~retry,this.Events.trigger("retry",`Retrying ${this.options.id} after ${retryAfter} ms`,eventInfo),this.retryCount++,run(retryAfter)):(this.doDone(eventInfo),await free(this.options,eventInfo),this._assertStatus("DONE"),this._reject(error))}doDone(eventInfo){return this._assertStatus("EXECUTING"),this._states.next(this.options.id),this.Events.trigger("done",eventInfo)}};parser$2=parser,BottleneckError$2=BottleneckError_1;var BottleneckError$3,LocalDatastore_1=class LocalDatastore{constructor(instance,storeOptions,storeInstanceOptions){this.instance=instance,this.storeOptions=storeOptions,this.clientId=this.instance._randomIndex(),parser$2.load(storeInstanceOptions,storeInstanceOptions,this),this._nextRequest=this._lastReservoirRefresh=this._lastReservoirIncrease=Date.now(),this._running=0,this._done=0,this._unblockTime=0,this.ready=this.Promise.resolve(),this.clients={},this._startHeartbeat()}_startHeartbeat(){var base;return null==this.heartbeat&&(null!=this.storeOptions.reservoirRefreshInterval&&null!=this.storeOptions.reservoirRefreshAmount||null!=this.storeOptions.reservoirIncreaseInterval&&null!=this.storeOptions.reservoirIncreaseAmount)?"function"==typeof(base=this.heartbeat=setInterval((()=>{var amount,incr,maximum,now,reservoir;if(now=Date.now(),null!=this.storeOptions.reservoirRefreshInterval&&now>=this._lastReservoirRefresh+this.storeOptions.reservoirRefreshInterval&&(this._lastReservoirRefresh=now,this.storeOptions.reservoir=this.storeOptions.reservoirRefreshAmount,this.instance._drainAll(this.computeCapacity())),null!=this.storeOptions.reservoirIncreaseInterval&&now>=this._lastReservoirIncrease+this.storeOptions.reservoirIncreaseInterval&&(({reservoirIncreaseAmount:amount,reservoirIncreaseMaximum:maximum,reservoir}=this.storeOptions),this._lastReservoirIncrease=now,(incr=null!=maximum?Math.min(amount,maximum-reservoir):amount)>0))return this.storeOptions.reservoir+=incr,this.instance._drainAll(this.computeCapacity())}),this.heartbeatInterval)).unref?base.unref():void 0:clearInterval(this.heartbeat)}async __publish__(message){return await this.yieldLoop(),this.instance.Events.trigger("message",message.toString())}async __disconnect__(flush){return await this.yieldLoop(),clearInterval(this.heartbeat),this.Promise.resolve()}yieldLoop(t=0){return new this.Promise((function(resolve,reject){return setTimeout(resolve,t)}))}computePenalty(){var ref;return null!=(ref=this.storeOptions.penalty)?ref:15*this.storeOptions.minTime||5e3}async __updateSettings__(options){return await this.yieldLoop(),parser$2.overwrite(options,options,this.storeOptions),this._startHeartbeat(),this.instance._drainAll(this.computeCapacity()),!0}async __running__(){return await this.yieldLoop(),this._running}async __queued__(){return await this.yieldLoop(),this.instance.queued()}async __done__(){return await this.yieldLoop(),this._done}async __groupCheck__(time){return await this.yieldLoop(),this._nextRequest+this.timeout<time}computeCapacity(){var maxConcurrent,reservoir;return({maxConcurrent,reservoir}=this.storeOptions),null!=maxConcurrent&&null!=reservoir?Math.min(maxConcurrent-this._running,reservoir):null!=maxConcurrent?maxConcurrent-this._running:null!=reservoir?reservoir:null}conditionsCheck(weight){var capacity;return null==(capacity=this.computeCapacity())||weight<=capacity}async __incrementReservoir__(incr){var reservoir;return await this.yieldLoop(),reservoir=this.storeOptions.reservoir+=incr,this.instance._drainAll(this.computeCapacity()),reservoir}async __currentReservoir__(){return await this.yieldLoop(),this.storeOptions.reservoir}isBlocked(now){return this._unblockTime>=now}check(weight,now){return this.conditionsCheck(weight)&&this._nextRequest-now<=0}async __check__(weight){var now;return await this.yieldLoop(),now=Date.now(),this.check(weight,now)}async __register__(index,weight,expiration){var now,wait;return await this.yieldLoop(),now=Date.now(),this.conditionsCheck(weight)?(this._running+=weight,null!=this.storeOptions.reservoir&&(this.storeOptions.reservoir-=weight),wait=Math.max(this._nextRequest-now,0),this._nextRequest=now+wait+this.storeOptions.minTime,{success:!0,wait,reservoir:this.storeOptions.reservoir}):{success:!1}}strategyIsBlock(){return 3===this.storeOptions.strategy}async __submit__(queueLength,weight){var blocked,now,reachedHWM;if(await this.yieldLoop(),null!=this.storeOptions.maxConcurrent&&weight>this.storeOptions.maxConcurrent)throw new BottleneckError$2(`Impossible to add a job having a weight of ${weight} to a limiter having a maxConcurrent setting of ${this.storeOptions.maxConcurrent}`);return now=Date.now(),reachedHWM=null!=this.storeOptions.highWater&&queueLength===this.storeOptions.highWater&&!this.check(weight,now),(blocked=this.strategyIsBlock()&&(reachedHWM||this.isBlocked(now)))&&(this._unblockTime=now+this.computePenalty(),this._nextRequest=this._unblockTime+this.storeOptions.minTime,this.instance._dropAllQueued()),{reachedHWM,blocked,strategy:this.storeOptions.strategy}}async __free__(index,weight){return await this.yieldLoop(),this._running-=weight,this._done+=weight,this.instance._drainAll(this.computeCapacity()),{running:this._running}}};BottleneckError$3=BottleneckError_1;var DLList$2,States_1=class States{constructor(status1){this.status=status1,this._jobs={},this.counts=this.status.map((function(){return 0}))}next(id){var current,next;return next=(current=this._jobs[id])+1,null!=current&&next<this.status.length?(this.counts[current]--,this.counts[next]++,this._jobs[id]++):null!=current?(this.counts[current]--,delete this._jobs[id]):void 0}start(id){var initial;return initial=0,this._jobs[id]=initial,this.counts[initial]++}remove(id){var current;return null!=(current=this._jobs[id])&&(this.counts[current]--,delete this._jobs[id]),null!=current}jobStatus(id){var ref;return null!=(ref=this.status[this._jobs[id]])?ref:null}statusJobs(status){var k,pos,ref,results;if(null!=status){if((pos=this.status.indexOf(status))<0)throw new BottleneckError$3(`status must be one of ${this.status.join(", ")}`);for(k in results=[],ref=this._jobs)ref[k]===pos&&results.push(k);return results}return Object.keys(this._jobs)}statusCounts(){return this.counts.reduce(((acc,v,i)=>(acc[this.status[i]]=v,acc)),{})}};DLList$2=DLList_1;var Events$2,IORedisConnection$1,RedisConnection$1,Scripts$1,parser$3,Sync_1=class Sync{constructor(name,Promise){this.schedule=this.schedule.bind(this),this.name=name,this.Promise=Promise,this._running=0,this._queue=new DLList$2}isEmpty(){return 0===this._queue.length}async _tryToRun(){var args,cb,error,reject,resolve,returned,task;if(this._running<1&&this._queue.length>0)return this._running++,({task,args,resolve,reject}=this._queue.shift()),cb=await async function(){try{return returned=await task(...args),function(){return resolve(returned)}}catch(error1){return error=error1,function(){return reject(error)}}}(),this._running--,this._tryToRun(),cb()}schedule(task,...args){var promise,reject,resolve;return resolve=reject=null,promise=new this.Promise((function(_resolve,_reject){return resolve=_resolve,reject=_reject})),this._queue.push({task,args,resolve,reject}),this._tryToRun(),promise}},version="2.19.5",version$1={version},version$2=Object.freeze({version,default:version$1}),require$$2=()=>console.log("You must import the full version of Bottleneck in order to use this feature."),require$$3=()=>console.log("You must import the full version of Bottleneck in order to use this feature.");parser$3=parser,Events$2=Events_1,RedisConnection$1=require$$2,IORedisConnection$1=require$$3,Scripts$1=()=>console.log("You must import the full version of Bottleneck in order to use this feature.");var Events$3,parser$4,Group_1=function(){class Group{constructor(limiterOptions={}){this.deleteKey=this.deleteKey.bind(this),this.limiterOptions=limiterOptions,parser$3.load(this.limiterOptions,this.defaults,this),this.Events=new Events$2(this),this.instances={},this.Bottleneck=Bottleneck_1,this._startAutoCleanup(),this.sharedConnection=null!=this.connection,null==this.connection&&("redis"===this.limiterOptions.datastore?this.connection=new RedisConnection$1(Object.assign({},this.limiterOptions,{Events:this.Events})):"ioredis"===this.limiterOptions.datastore&&(this.connection=new IORedisConnection$1(Object.assign({},this.limiterOptions,{Events:this.Events}))))}key(key=""){var ref;return null!=(ref=this.instances[key])?ref:(()=>{var limiter;return limiter=this.instances[key]=new this.Bottleneck(Object.assign(this.limiterOptions,{id:`${this.id}-${key}`,timeout:this.timeout,connection:this.connection})),this.Events.trigger("created",limiter,key),limiter})()}async deleteKey(key=""){var deleted,instance;return instance=this.instances[key],this.connection&&(deleted=await this.connection.__runCommand__(["del",...Scripts$1.allKeys(`${this.id}-${key}`)])),null!=instance&&(delete this.instances[key],await instance.disconnect()),null!=instance||deleted>0}limiters(){var k,ref,results,v;for(k in results=[],ref=this.instances)v=ref[k],results.push({key:k,limiter:v});return results}keys(){return Object.keys(this.instances)}async clusterKeys(){var cursor,end,found,i,k,keys,len,next,start;if(null==this.connection)return this.Promise.resolve(this.keys());for(keys=[],cursor=null,start=`b_${this.id}-`.length,end=9;0!==cursor;)for([next,found]=await this.connection.__runCommand__(["scan",null!=cursor?cursor:0,"match",`b_${this.id}-*_settings`,"count",1e4]),cursor=~~next,i=0,len=found.length;i<len;i++)k=found[i],keys.push(k.slice(start,-end));return keys}_startAutoCleanup(){var base;return clearInterval(this.interval),"function"==typeof(base=this.interval=setInterval((async()=>{var e,k,ref,results,time,v;for(k in time=Date.now(),results=[],ref=this.instances){v=ref[k];try{await v._store.__groupCheck__(time)?results.push(this.deleteKey(k)):results.push(void 0)}catch(error){e=error,results.push(v.Events.trigger("error",e))}}return results}),this.timeout/2)).unref?base.unref():void 0}updateSettings(options={}){if(parser$3.overwrite(options,this.defaults,this),parser$3.overwrite(options,options,this.limiterOptions),null!=options.timeout)return this._startAutoCleanup()}disconnect(flush=!0){var ref;if(!this.sharedConnection)return null!=(ref=this.connection)?ref.disconnect(flush):void 0}}return Group.prototype.defaults={timeout:3e5,connection:null,Promise,id:"group-key"},Group}.call(commonjsGlobal);parser$4=parser,Events$3=Events_1;var DEFAULT_PRIORITY$1,Events$4,Job$1,LocalDatastore$1,NUM_PRIORITIES$1,Queues$1,RedisDatastore$1,States$1,Sync$1,parser$5,Batcher_1=function(){class Batcher{constructor(options={}){this.options=options,parser$4.load(this.options,this.defaults,this),this.Events=new Events$3(this),this._arr=[],this._resetPromise(),this._lastFlush=Date.now()}_resetPromise(){return this._promise=new this.Promise(((res,rej)=>this._resolve=res))}_flush(){return clearTimeout(this._timeout),this._lastFlush=Date.now(),this._resolve(),this.Events.trigger("batch",this._arr),this._arr=[],this._resetPromise()}add(data){var ret;return this._arr.push(data),ret=this._promise,this._arr.length===this.maxSize?this._flush():null!=this.maxTime&&1===this._arr.length&&(this._timeout=setTimeout((()=>this._flush()),this.maxTime)),ret}}return Batcher.prototype.defaults={maxTime:null,maxSize:null,Promise},Batcher}.call(commonjsGlobal),require$$4$1=()=>console.log("You must import the full version of Bottleneck in order to use this feature."),require$$8=getCjsExportFromNamespace(version$2),splice=[].splice;NUM_PRIORITIES$1=10,DEFAULT_PRIORITY$1=5,parser$5=parser,Queues$1=Queues_1,Job$1=Job_1,LocalDatastore$1=LocalDatastore_1,RedisDatastore$1=require$$4$1,Events$4=Events_1,States$1=States_1,Sync$1=Sync_1;var Bottleneck_1=function(){class Bottleneck{constructor(options={},...invalid){var storeInstanceOptions,storeOptions;this._addToQueue=this._addToQueue.bind(this),this._validateOptions(options,invalid),parser$5.load(options,this.instanceDefaults,this),this._queues=new Queues$1(NUM_PRIORITIES$1),this._scheduled={},this._states=new States$1(["RECEIVED","QUEUED","RUNNING","EXECUTING"].concat(this.trackDoneStatus?["DONE"]:[])),this._limiter=null,this.Events=new Events$4(this),this._submitLock=new Sync$1("submit",this.Promise),this._registerLock=new Sync$1("register",this.Promise),storeOptions=parser$5.load(options,this.storeDefaults,{}),this._store=function(){if("redis"===this.datastore||"ioredis"===this.datastore||null!=this.connection)return storeInstanceOptions=parser$5.load(options,this.redisStoreDefaults,{}),new RedisDatastore$1(this,storeOptions,storeInstanceOptions);if("local"===this.datastore)return storeInstanceOptions=parser$5.load(options,this.localStoreDefaults,{}),new LocalDatastore$1(this,storeOptions,storeInstanceOptions);throw new Bottleneck.prototype.BottleneckError(`Invalid datastore type: ${this.datastore}`)}.call(this),this._queues.on("leftzero",(()=>{var ref;return null!=(ref=this._store.heartbeat)&&"function"==typeof ref.ref?ref.ref():void 0})),this._queues.on("zero",(()=>{var ref;return null!=(ref=this._store.heartbeat)&&"function"==typeof ref.unref?ref.unref():void 0}))}_validateOptions(options,invalid){if(null==options||"object"!=typeof options||0!==invalid.length)throw new Bottleneck.prototype.BottleneckError("Bottleneck v2 takes a single object argument. Refer to https://github.com/SGrondin/bottleneck#upgrading-to-v2 if you're upgrading from Bottleneck v1.")}ready(){return this._store.ready}clients(){return this._store.clients}channel(){return`b_${this.id}`}channel_client(){return`b_${this.id}_${this._store.clientId}`}publish(message){return this._store.__publish__(message)}disconnect(flush=!0){return this._store.__disconnect__(flush)}chain(_limiter){return this._limiter=_limiter,this}queued(priority){return this._queues.queued(priority)}clusterQueued(){return this._store.__queued__()}empty(){return 0===this.queued()&&this._submitLock.isEmpty()}running(){return this._store.__running__()}done(){return this._store.__done__()}jobStatus(id){return this._states.jobStatus(id)}jobs(status){return this._states.statusJobs(status)}counts(){return this._states.statusCounts()}_randomIndex(){return Math.random().toString(36).slice(2)}check(weight=1){return this._store.__check__(weight)}_clearGlobalState(index){return null!=this._scheduled[index]&&(clearTimeout(this._scheduled[index].expiration),delete this._scheduled[index],!0)}async _free(index,job,options,eventInfo){var e,running;try{if(({running}=await this._store.__free__(index,options.weight)),this.Events.trigger("debug",`Freed ${options.id}`,eventInfo),0===running&&this.empty())return this.Events.trigger("idle")}catch(error1){return e=error1,this.Events.trigger("error",e)}}_run(index,job,wait){var clearGlobalState,free,run;return job.doRun(),clearGlobalState=this._clearGlobalState.bind(this,index),run=this._run.bind(this,index,job),free=this._free.bind(this,index,job),this._scheduled[index]={timeout:setTimeout((()=>job.doExecute(this._limiter,clearGlobalState,run,free)),wait),expiration:null!=job.options.expiration?setTimeout((function(){return job.doExpire(clearGlobalState,run,free)}),wait+job.options.expiration):void 0,job}}_drainOne(capacity){return this._registerLock.schedule((()=>{var args,index,next,options,queue;return 0===this.queued()?this.Promise.resolve(null):(queue=this._queues.getFirst(),({options,args}=next=queue.first()),null!=capacity&&options.weight>capacity?this.Promise.resolve(null):(this.Events.trigger("debug",`Draining ${options.id}`,{args,options}),index=this._randomIndex(),this._store.__register__(index,options.weight,options.expiration).then((({success,wait,reservoir})=>{var empty;return this.Events.trigger("debug",`Drained ${options.id}`,{success,args,options}),success?(queue.shift(),(empty=this.empty())&&this.Events.trigger("empty"),0===reservoir&&this.Events.trigger("depleted",empty),this._run(index,next,wait),this.Promise.resolve(options.weight)):this.Promise.resolve(null)}))))}))}_drainAll(capacity,total=0){return this._drainOne(capacity).then((drained=>{var newCapacity;return null!=drained?(newCapacity=null!=capacity?capacity-drained:capacity,this._drainAll(newCapacity,total+drained)):this.Promise.resolve(total)})).catch((e=>this.Events.trigger("error",e)))}_dropAllQueued(message){return this._queues.shiftAll((function(job){return job.doDrop({message})}))}stop(options={}){var done,waitForExecuting;return options=parser$5.load(options,this.stopDefaults),waitForExecuting=at=>{var finished;return finished=()=>{var counts;return(counts=this._states.counts)[0]+counts[1]+counts[2]+counts[3]===at},new this.Promise(((resolve,reject)=>finished()?resolve():this.on("done",(()=>{if(finished())return this.removeAllListeners("done"),resolve()}))))},done=options.dropWaitingJobs?(this._run=function(index,next){return next.doDrop({message:options.dropErrorMessage})},this._drainOne=()=>this.Promise.resolve(null),this._registerLock.schedule((()=>this._submitLock.schedule((()=>{var k,ref,v;for(k in ref=this._scheduled)v=ref[k],"RUNNING"===this.jobStatus(v.job.options.id)&&(clearTimeout(v.timeout),clearTimeout(v.expiration),v.job.doDrop({message:options.dropErrorMessage}));return this._dropAllQueued(options.dropErrorMessage),waitForExecuting(0)}))))):this.schedule({priority:NUM_PRIORITIES$1-1,weight:0},(()=>waitForExecuting(1))),this._receive=function(job){return job._reject(new Bottleneck.prototype.BottleneckError(options.enqueueErrorMessage))},this.stop=()=>this.Promise.reject(new Bottleneck.prototype.BottleneckError("stop() has already been called")),done}async _addToQueue(job){var args,blocked,error,options,reachedHWM,shifted,strategy;({args,options}=job);try{({reachedHWM,blocked,strategy}=await this._store.__submit__(this.queued(),options.weight))}catch(error1){return error=error1,this.Events.trigger("debug",`Could not queue ${options.id}`,{args,options,error}),job.doDrop({error}),!1}return blocked?(job.doDrop(),!0):reachedHWM&&(null!=(shifted=strategy===Bottleneck.prototype.strategy.LEAK?this._queues.shiftLastFrom(options.priority):strategy===Bottleneck.prototype.strategy.OVERFLOW_PRIORITY?this._queues.shiftLastFrom(options.priority+1):strategy===Bottleneck.prototype.strategy.OVERFLOW?job:void 0)&&shifted.doDrop(),null==shifted||strategy===Bottleneck.prototype.strategy.OVERFLOW)?(null==shifted&&job.doDrop(),reachedHWM):(job.doQueue(reachedHWM,blocked),this._queues.push(job),await this._drainAll(),reachedHWM)}_receive(job){return null!=this._states.jobStatus(job.options.id)?(job._reject(new Bottleneck.prototype.BottleneckError(`A job with the same id already exists (id=${job.options.id})`)),!1):(job.doReceive(),this._submitLock.schedule(this._addToQueue,job))}submit(...args){var cb,fn,job,options,ref,ref1,task;return"function"==typeof args[0]?(ref=args,[fn,...args]=ref,[cb]=splice.call(args,-1),options=parser$5.load({},this.jobDefaults)):(ref1=args,[options,fn,...args]=ref1,[cb]=splice.call(args,-1),options=parser$5.load(options,this.jobDefaults)),task=(...args)=>new this.Promise((function(resolve,reject){return fn(...args,(function(...args){return(null!=args[0]?reject:resolve)(args)}))})),(job=new Job$1(task,args,options,this.jobDefaults,this.rejectOnDrop,this.Events,this._states,this.Promise)).promise.then((function(args){return"function"==typeof cb?cb(...args):void 0})).catch((function(args){return Array.isArray(args)?"function"==typeof cb?cb(...args):void 0:"function"==typeof cb?cb(args):void 0})),this._receive(job)}schedule(...args){var job,options,task;return"function"==typeof args[0]?([task,...args]=args,options={}):[options,task,...args]=args,job=new Job$1(task,args,options,this.jobDefaults,this.rejectOnDrop,this.Events,this._states,this.Promise),this._receive(job),job.promise}wrap(fn){var schedule,wrapped;return schedule=this.schedule.bind(this),(wrapped=function(...args){return schedule(fn.bind(this),...args)}).withOptions=function(options,...args){return schedule(options,fn,...args)},wrapped}async updateSettings(options={}){return await this._store.__updateSettings__(parser$5.overwrite(options,this.storeDefaults)),parser$5.overwrite(options,this.instanceDefaults,this),this}currentReservoir(){return this._store.__currentReservoir__()}incrementReservoir(incr=0){return this._store.__incrementReservoir__(incr)}}return Bottleneck.default=Bottleneck,Bottleneck.Events=Events$4,Bottleneck.version=Bottleneck.prototype.version=require$$8.version,Bottleneck.strategy=Bottleneck.prototype.strategy={LEAK:1,OVERFLOW:2,OVERFLOW_PRIORITY:4,BLOCK:3},Bottleneck.BottleneckError=Bottleneck.prototype.BottleneckError=BottleneckError_1,Bottleneck.Group=Bottleneck.prototype.Group=Group_1,Bottleneck.RedisConnection=Bottleneck.prototype.RedisConnection=require$$2,Bottleneck.IORedisConnection=Bottleneck.prototype.IORedisConnection=require$$3,Bottleneck.Batcher=Bottleneck.prototype.Batcher=Batcher_1,Bottleneck.prototype.jobDefaults={priority:DEFAULT_PRIORITY$1,weight:1,expiration:null,id:"<no-id>"},Bottleneck.prototype.storeDefaults={maxConcurrent:null,minTime:0,highWater:null,strategy:Bottleneck.prototype.strategy.LEAK,penalty:null,reservoir:null,reservoirRefreshInterval:null,reservoirRefreshAmount:null,reservoirIncreaseInterval:null,reservoirIncreaseAmount:null,reservoirIncreaseMaximum:null},Bottleneck.prototype.localStoreDefaults={Promise,timeout:null,heartbeatInterval:250},Bottleneck.prototype.redisStoreDefaults={Promise,timeout:null,heartbeatInterval:5e3,clientTimeout:1e4,Redis:null,clientOptions:{},clusterNodes:null,clearDatastore:!1,connection:null},Bottleneck.prototype.instanceDefaults={datastore:"local",connection:null,id:"<no-id>",rejectOnDrop:!0,trackDoneStatus:!1,Promise},Bottleneck.prototype.stopDefaults={enqueueErrorMessage:"This limiter has been stopped and cannot accept new jobs.",dropWaitingJobs:!0,dropErrorMessage:"This limiter has been stopped."},Bottleneck}.call(commonjsGlobal);return Bottleneck_1}()},"./node_modules/btoa-lite/btoa-browser.js":module=>{module.exports=function _btoa(str){return btoa(str)}},"./node_modules/clean-stack/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";const os=__webpack_require__("?e4dd"),extractPathRegex=/\s+at.*(?:\(|\s)(.*)\)?/,pathRegex=/^(?:(?:(?:node|(?:internal\/[\w/]*|.*node_modules\/(?:babel-polyfill|pirates)\/.*)?\w+)\.js:\d+:\d+)|native)/,homeDir=void 0===os.homedir?"":os.homedir();module.exports=(stack,options)=>(options=Object.assign({pretty:!1},options),stack.replace(/\\/g,"/").split("\n").filter((line=>{const pathMatches=line.match(extractPathRegex);if(null===pathMatches||!pathMatches[1])return!0;const match=pathMatches[1];return!match.includes(".app/Contents/Resources/electron.asar")&&!match.includes(".app/Contents/Resources/default_app.asar")&&!pathRegex.test(match)})).filter((line=>""!==line.trim())).map((line=>options.pretty?line.replace(extractPathRegex,((m,p1)=>m.replace(p1,p1.replace(homeDir,"~")))):line)).join("\n"))},"./node_modules/deprecation/dist-web/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{Deprecation:()=>Deprecation});class Deprecation extends Error{constructor(message){super(message),Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor),this.name="Deprecation"}}},"./node_modules/indent-string/index.js":module=>{"use strict";module.exports=(string,count=1,options)=>{if(options={indent:" ",includeEmptyLines:!1,...options},"string"!=typeof string)throw new TypeError(`Expected \`input\` to be a \`string\`, got \`${typeof string}\``);if("number"!=typeof count)throw new TypeError(`Expected \`count\` to be a \`number\`, got \`${typeof count}\``);if("string"!=typeof options.indent)throw new TypeError(`Expected \`options.indent\` to be a \`string\`, got \`${typeof options.indent}\``);if(0===count)return string;const regex=options.includeEmptyLines?/^/gm:/^(?!\s*$)/gm;return string.replace(regex,options.indent.repeat(count))}},"./node_modules/lodash.debounce/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{var NAN=NaN,symbolTag="[object Symbol]",reTrim=/^\s+|\s+$/g,reIsBadHex=/^[-+]0x[0-9a-f]+$/i,reIsBinary=/^0b[01]+$/i,reIsOctal=/^0o[0-7]+$/i,freeParseInt=parseInt,freeGlobal="object"==typeof __webpack_require__.g&&__webpack_require__.g&&__webpack_require__.g.Object===Object&&__webpack_require__.g,freeSelf="object"==typeof self&&self&&self.Object===Object&&self,root=freeGlobal||freeSelf||Function("return this")(),objectToString=Object.prototype.toString,nativeMax=Math.max,nativeMin=Math.min,now=function(){return root.Date.now()};function isObject(value){var type=typeof value;return!!value&&("object"==type||"function"==type)}function toNumber(value){if("number"==typeof value)return value;if(function isSymbol(value){return"symbol"==typeof value||function isObjectLike(value){return!!value&&"object"==typeof value}(value)&&objectToString.call(value)==symbolTag}(value))return NAN;if(isObject(value)){var other="function"==typeof value.valueOf?value.valueOf():value;value=isObject(other)?other+"":other}if("string"!=typeof value)return 0===value?value:+value;value=value.replace(reTrim,"");var isBinary=reIsBinary.test(value);return isBinary||reIsOctal.test(value)?freeParseInt(value.slice(2),isBinary?2:8):reIsBadHex.test(value)?NAN:+value}module.exports=function debounce(func,wait,options){var lastArgs,lastThis,maxWait,result,timerId,lastCallTime,lastInvokeTime=0,leading=!1,maxing=!1,trailing=!0;if("function"!=typeof func)throw new TypeError("Expected a function");function invokeFunc(time){var args=lastArgs,thisArg=lastThis;return lastArgs=lastThis=void 0,lastInvokeTime=time,result=func.apply(thisArg,args)}function shouldInvoke(time){var timeSinceLastCall=time-lastCallTime;return void 0===lastCallTime||timeSinceLastCall>=wait||timeSinceLastCall<0||maxing&&time-lastInvokeTime>=maxWait}function timerExpired(){var time=now();if(shouldInvoke(time))return trailingEdge(time);timerId=setTimeout(timerExpired,function remainingWait(time){var result=wait-(time-lastCallTime);return maxing?nativeMin(result,maxWait-(time-lastInvokeTime)):result}(time))}function trailingEdge(time){return timerId=void 0,trailing&&lastArgs?invokeFunc(time):(lastArgs=lastThis=void 0,result)}function debounced(){var time=now(),isInvoking=shouldInvoke(time);if(lastArgs=arguments,lastThis=this,lastCallTime=time,isInvoking){if(void 0===timerId)return function leadingEdge(time){return lastInvokeTime=time,timerId=setTimeout(timerExpired,wait),leading?invokeFunc(time):result}(lastCallTime);if(maxing)return timerId=setTimeout(timerExpired,wait),invokeFunc(lastCallTime)}return void 0===timerId&&(timerId=setTimeout(timerExpired,wait)),result}return wait=toNumber(wait)||0,isObject(options)&&(leading=!!options.leading,maxWait=(maxing="maxWait"in options)?nativeMax(toNumber(options.maxWait)||0,wait):maxWait,trailing="trailing"in options?!!options.trailing:trailing),debounced.cancel=function cancel(){void 0!==timerId&&clearTimeout(timerId),lastInvokeTime=0,lastArgs=lastCallTime=lastThis=timerId=void 0},debounced.flush=function flush(){return void 0===timerId?result:trailingEdge(now())},debounced}},"./node_modules/octokit/dist-web/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{vd:()=>Octokit});var dist_web=__webpack_require__("./node_modules/@octokit/core/dist-web/index.js");function iterator(octokit,route,parameters){const options="function"==typeof route?route.endpoint(parameters):octokit.request.endpoint(route,parameters),requestMethod="function"==typeof route?route:octokit.request,method=options.method,headers=options.headers;let url=options.url;return{[Symbol.asyncIterator]:()=>({async next(){if(!url)return{done:!0};try{const normalizedResponse=function normalizePaginatedListResponse(response){if(!response.data)return{...response,data:[]};if(!("total_count"in response.data)||"url"in response.data)return response;const incompleteResults=response.data.incomplete_results,repositorySelection=response.data.repository_selection,totalCount=response.data.total_count;delete response.data.incomplete_results,delete response.data.repository_selection,delete response.data.total_count;const namespaceKey=Object.keys(response.data)[0],data=response.data[namespaceKey];return response.data=data,void 0!==incompleteResults&&(response.data.incomplete_results=incompleteResults),void 0!==repositorySelection&&(response.data.repository_selection=repositorySelection),response.data.total_count=totalCount,response}(await requestMethod({method,url,headers}));return url=((normalizedResponse.headers.link||"").match(/<([^>]+)>;\s*rel="next"/)||[])[1],{value:normalizedResponse}}catch(error){if(409!==error.status)throw error;return url="",{value:{status:200,headers:{},data:[]}}}}})}}function paginate(octokit,route,parameters,mapFn){return"function"==typeof parameters&&(mapFn=parameters,parameters=void 0),gather(octokit,[],iterator(octokit,route,parameters)[Symbol.asyncIterator](),mapFn)}function gather(octokit,results,iterator2,mapFn){return iterator2.next().then((result=>{if(result.done)return results;let earlyExit=!1;return results=results.concat(mapFn?mapFn(result.value,(function done(){earlyExit=!0})):result.value.data),earlyExit?results:gather(octokit,results,iterator2,mapFn)}))}var composePaginateRest=Object.assign(paginate,{iterator});function paginateRest(octokit){return{paginate:Object.assign(paginate.bind(null,octokit),{iterator:iterator.bind(null,octokit)})}}paginateRest.VERSION="9.1.5";var MissingCursorChange=class extends Error{constructor(pageInfo,cursorValue){super(((path,cursorValue)=>`The cursor at "${path.join(",")}" did not change its value "${cursorValue}" after a page transition. Please make sure your that your query is set up correctly.`)(pageInfo.pathInQuery,cursorValue)),this.pageInfo=pageInfo,this.cursorValue=cursorValue,this.name="MissingCursorChangeError",Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor)}},MissingPageInfo=class extends Error{constructor(response){super(`No pageInfo property found in response. Please make sure to specify the pageInfo in your query. Response-Data: ${JSON.stringify(response,null,2)}`),this.response=response,this.name="MissingPageInfo",Error.captureStackTrace&&Error.captureStackTrace(this,this.constructor)}};function findPaginatedResourcePath(responseData){const paginatedResourcePath=deepFindPathToProperty(responseData,"pageInfo");if(0===paginatedResourcePath.length)throw new MissingPageInfo(responseData);return paginatedResourcePath}var deepFindPathToProperty=(object,searchProp,path=[])=>{for(const key of Object.keys(object)){const currentPath=[...path,key],currentValue=object[key];if(currentValue.hasOwnProperty(searchProp))return currentPath;if(value=currentValue,"[object Object]"===Object.prototype.toString.call(value)){const result=deepFindPathToProperty(currentValue,searchProp,currentPath);if(result.length>0)return result}}var value;return[]},get=(object,path)=>path.reduce(((current,nextProperty)=>current[nextProperty]),object),set=(object,path,mutator)=>{const lastProperty=path[path.length-1],parentPath=[...path].slice(0,-1),parent=get(object,parentPath);parent[lastProperty]="function"==typeof mutator?mutator(parent[lastProperty]):mutator},isForwardSearch=givenPageInfo=>givenPageInfo.hasOwnProperty("hasNextPage"),createIterator=octokit=>(query,initialParameters={})=>{let nextPageExists=!0,parameters={...initialParameters};return{[Symbol.asyncIterator]:()=>({async next(){if(!nextPageExists)return{done:!0,value:{}};const response=await octokit.graphql(query,parameters),pageInfoContext=(responseData=>{const pageInfoPath=findPaginatedResourcePath(responseData);return{pathInQuery:pageInfoPath,pageInfo:get(responseData,[...pageInfoPath,"pageInfo"])}})(response),nextCursorValue=(pageInfo=pageInfoContext.pageInfo,isForwardSearch(pageInfo)?pageInfo.endCursor:pageInfo.startCursor);var pageInfo;if(nextPageExists=(pageInfo=>isForwardSearch(pageInfo)?pageInfo.hasNextPage:pageInfo.hasPreviousPage)(pageInfoContext.pageInfo),nextPageExists&&nextCursorValue===parameters.cursor)throw new MissingCursorChange(pageInfoContext,nextCursorValue);return parameters={...parameters,cursor:nextCursorValue},{done:!1,value:response}}})}},mergeResponses=(response1,response2)=>{if(0===Object.keys(response1).length)return Object.assign(response1,response2);const path=findPaginatedResourcePath(response1),nodesPath=[...path,"nodes"],newNodes=get(response2,nodesPath);newNodes&&set(response1,nodesPath,(values=>[...values,...newNodes]));const edgesPath=[...path,"edges"],newEdges=get(response2,edgesPath);newEdges&&set(response1,edgesPath,(values=>[...values,...newEdges]));const pageInfoPath=[...path,"pageInfo"];return set(response1,pageInfoPath,get(response2,pageInfoPath)),response1},createPaginate=octokit=>{const iterator=createIterator(octokit);return async(query,initialParameters={})=>{let mergedResponse={};for await(const response of iterator(query,initialParameters))mergedResponse=mergeResponses(mergedResponse,response);return mergedResponse}};var endpoints_default={actions:{addCustomLabelsToSelfHostedRunnerForOrg:["POST /orgs/{org}/actions/runners/{runner_id}/labels"],addCustomLabelsToSelfHostedRunnerForRepo:["POST /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"],addSelectedRepoToOrgSecret:["PUT /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"],addSelectedRepoToOrgVariable:["PUT /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"],approveWorkflowRun:["POST /repos/{owner}/{repo}/actions/runs/{run_id}/approve"],cancelWorkflowRun:["POST /repos/{owner}/{repo}/actions/runs/{run_id}/cancel"],createEnvironmentVariable:["POST /repositories/{repository_id}/environments/{environment_name}/variables"],createOrUpdateEnvironmentSecret:["PUT /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"],createOrUpdateOrgSecret:["PUT /orgs/{org}/actions/secrets/{secret_name}"],createOrUpdateRepoSecret:["PUT /repos/{owner}/{repo}/actions/secrets/{secret_name}"],createOrgVariable:["POST /orgs/{org}/actions/variables"],createRegistrationTokenForOrg:["POST /orgs/{org}/actions/runners/registration-token"],createRegistrationTokenForRepo:["POST /repos/{owner}/{repo}/actions/runners/registration-token"],createRemoveTokenForOrg:["POST /orgs/{org}/actions/runners/remove-token"],createRemoveTokenForRepo:["POST /repos/{owner}/{repo}/actions/runners/remove-token"],createRepoVariable:["POST /repos/{owner}/{repo}/actions/variables"],createWorkflowDispatch:["POST /repos/{owner}/{repo}/actions/workflows/{workflow_id}/dispatches"],deleteActionsCacheById:["DELETE /repos/{owner}/{repo}/actions/caches/{cache_id}"],deleteActionsCacheByKey:["DELETE /repos/{owner}/{repo}/actions/caches{?key,ref}"],deleteArtifact:["DELETE /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],deleteEnvironmentSecret:["DELETE /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"],deleteEnvironmentVariable:["DELETE /repositories/{repository_id}/environments/{environment_name}/variables/{name}"],deleteOrgSecret:["DELETE /orgs/{org}/actions/secrets/{secret_name}"],deleteOrgVariable:["DELETE /orgs/{org}/actions/variables/{name}"],deleteRepoSecret:["DELETE /repos/{owner}/{repo}/actions/secrets/{secret_name}"],deleteRepoVariable:["DELETE /repos/{owner}/{repo}/actions/variables/{name}"],deleteSelfHostedRunnerFromOrg:["DELETE /orgs/{org}/actions/runners/{runner_id}"],deleteSelfHostedRunnerFromRepo:["DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}"],deleteWorkflowRun:["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}"],deleteWorkflowRunLogs:["DELETE /repos/{owner}/{repo}/actions/runs/{run_id}/logs"],disableSelectedRepositoryGithubActionsOrganization:["DELETE /orgs/{org}/actions/permissions/repositories/{repository_id}"],disableWorkflow:["PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/disable"],downloadArtifact:["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}/{archive_format}"],downloadJobLogsForWorkflowRun:["GET /repos/{owner}/{repo}/actions/jobs/{job_id}/logs"],downloadWorkflowRunAttemptLogs:["GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/logs"],downloadWorkflowRunLogs:["GET /repos/{owner}/{repo}/actions/runs/{run_id}/logs"],enableSelectedRepositoryGithubActionsOrganization:["PUT /orgs/{org}/actions/permissions/repositories/{repository_id}"],enableWorkflow:["PUT /repos/{owner}/{repo}/actions/workflows/{workflow_id}/enable"],forceCancelWorkflowRun:["POST /repos/{owner}/{repo}/actions/runs/{run_id}/force-cancel"],generateRunnerJitconfigForOrg:["POST /orgs/{org}/actions/runners/generate-jitconfig"],generateRunnerJitconfigForRepo:["POST /repos/{owner}/{repo}/actions/runners/generate-jitconfig"],getActionsCacheList:["GET /repos/{owner}/{repo}/actions/caches"],getActionsCacheUsage:["GET /repos/{owner}/{repo}/actions/cache/usage"],getActionsCacheUsageByRepoForOrg:["GET /orgs/{org}/actions/cache/usage-by-repository"],getActionsCacheUsageForOrg:["GET /orgs/{org}/actions/cache/usage"],getAllowedActionsOrganization:["GET /orgs/{org}/actions/permissions/selected-actions"],getAllowedActionsRepository:["GET /repos/{owner}/{repo}/actions/permissions/selected-actions"],getArtifact:["GET /repos/{owner}/{repo}/actions/artifacts/{artifact_id}"],getEnvironmentPublicKey:["GET /repositories/{repository_id}/environments/{environment_name}/secrets/public-key"],getEnvironmentSecret:["GET /repositories/{repository_id}/environments/{environment_name}/secrets/{secret_name}"],getEnvironmentVariable:["GET /repositories/{repository_id}/environments/{environment_name}/variables/{name}"],getGithubActionsDefaultWorkflowPermissionsOrganization:["GET /orgs/{org}/actions/permissions/workflow"],getGithubActionsDefaultWorkflowPermissionsRepository:["GET /repos/{owner}/{repo}/actions/permissions/workflow"],getGithubActionsPermissionsOrganization:["GET /orgs/{org}/actions/permissions"],getGithubActionsPermissionsRepository:["GET /repos/{owner}/{repo}/actions/permissions"],getJobForWorkflowRun:["GET /repos/{owner}/{repo}/actions/jobs/{job_id}"],getOrgPublicKey:["GET /orgs/{org}/actions/secrets/public-key"],getOrgSecret:["GET /orgs/{org}/actions/secrets/{secret_name}"],getOrgVariable:["GET /orgs/{org}/actions/variables/{name}"],getPendingDeploymentsForRun:["GET /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"],getRepoPermissions:["GET /repos/{owner}/{repo}/actions/permissions",{},{renamed:["actions","getGithubActionsPermissionsRepository"]}],getRepoPublicKey:["GET /repos/{owner}/{repo}/actions/secrets/public-key"],getRepoSecret:["GET /repos/{owner}/{repo}/actions/secrets/{secret_name}"],getRepoVariable:["GET /repos/{owner}/{repo}/actions/variables/{name}"],getReviewsForRun:["GET /repos/{owner}/{repo}/actions/runs/{run_id}/approvals"],getSelfHostedRunnerForOrg:["GET /orgs/{org}/actions/runners/{runner_id}"],getSelfHostedRunnerForRepo:["GET /repos/{owner}/{repo}/actions/runners/{runner_id}"],getWorkflow:["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}"],getWorkflowAccessToRepository:["GET /repos/{owner}/{repo}/actions/permissions/access"],getWorkflowRun:["GET /repos/{owner}/{repo}/actions/runs/{run_id}"],getWorkflowRunAttempt:["GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}"],getWorkflowRunUsage:["GET /repos/{owner}/{repo}/actions/runs/{run_id}/timing"],getWorkflowUsage:["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/timing"],listArtifactsForRepo:["GET /repos/{owner}/{repo}/actions/artifacts"],listEnvironmentSecrets:["GET /repositories/{repository_id}/environments/{environment_name}/secrets"],listEnvironmentVariables:["GET /repositories/{repository_id}/environments/{environment_name}/variables"],listJobsForWorkflowRun:["GET /repos/{owner}/{repo}/actions/runs/{run_id}/jobs"],listJobsForWorkflowRunAttempt:["GET /repos/{owner}/{repo}/actions/runs/{run_id}/attempts/{attempt_number}/jobs"],listLabelsForSelfHostedRunnerForOrg:["GET /orgs/{org}/actions/runners/{runner_id}/labels"],listLabelsForSelfHostedRunnerForRepo:["GET /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"],listOrgSecrets:["GET /orgs/{org}/actions/secrets"],listOrgVariables:["GET /orgs/{org}/actions/variables"],listRepoOrganizationSecrets:["GET /repos/{owner}/{repo}/actions/organization-secrets"],listRepoOrganizationVariables:["GET /repos/{owner}/{repo}/actions/organization-variables"],listRepoSecrets:["GET /repos/{owner}/{repo}/actions/secrets"],listRepoVariables:["GET /repos/{owner}/{repo}/actions/variables"],listRepoWorkflows:["GET /repos/{owner}/{repo}/actions/workflows"],listRunnerApplicationsForOrg:["GET /orgs/{org}/actions/runners/downloads"],listRunnerApplicationsForRepo:["GET /repos/{owner}/{repo}/actions/runners/downloads"],listSelectedReposForOrgSecret:["GET /orgs/{org}/actions/secrets/{secret_name}/repositories"],listSelectedReposForOrgVariable:["GET /orgs/{org}/actions/variables/{name}/repositories"],listSelectedRepositoriesEnabledGithubActionsOrganization:["GET /orgs/{org}/actions/permissions/repositories"],listSelfHostedRunnersForOrg:["GET /orgs/{org}/actions/runners"],listSelfHostedRunnersForRepo:["GET /repos/{owner}/{repo}/actions/runners"],listWorkflowRunArtifacts:["GET /repos/{owner}/{repo}/actions/runs/{run_id}/artifacts"],listWorkflowRuns:["GET /repos/{owner}/{repo}/actions/workflows/{workflow_id}/runs"],listWorkflowRunsForRepo:["GET /repos/{owner}/{repo}/actions/runs"],reRunJobForWorkflowRun:["POST /repos/{owner}/{repo}/actions/jobs/{job_id}/rerun"],reRunWorkflow:["POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun"],reRunWorkflowFailedJobs:["POST /repos/{owner}/{repo}/actions/runs/{run_id}/rerun-failed-jobs"],removeAllCustomLabelsFromSelfHostedRunnerForOrg:["DELETE /orgs/{org}/actions/runners/{runner_id}/labels"],removeAllCustomLabelsFromSelfHostedRunnerForRepo:["DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"],removeCustomLabelFromSelfHostedRunnerForOrg:["DELETE /orgs/{org}/actions/runners/{runner_id}/labels/{name}"],removeCustomLabelFromSelfHostedRunnerForRepo:["DELETE /repos/{owner}/{repo}/actions/runners/{runner_id}/labels/{name}"],removeSelectedRepoFromOrgSecret:["DELETE /orgs/{org}/actions/secrets/{secret_name}/repositories/{repository_id}"],removeSelectedRepoFromOrgVariable:["DELETE /orgs/{org}/actions/variables/{name}/repositories/{repository_id}"],reviewCustomGatesForRun:["POST /repos/{owner}/{repo}/actions/runs/{run_id}/deployment_protection_rule"],reviewPendingDeploymentsForRun:["POST /repos/{owner}/{repo}/actions/runs/{run_id}/pending_deployments"],setAllowedActionsOrganization:["PUT /orgs/{org}/actions/permissions/selected-actions"],setAllowedActionsRepository:["PUT /repos/{owner}/{repo}/actions/permissions/selected-actions"],setCustomLabelsForSelfHostedRunnerForOrg:["PUT /orgs/{org}/actions/runners/{runner_id}/labels"],setCustomLabelsForSelfHostedRunnerForRepo:["PUT /repos/{owner}/{repo}/actions/runners/{runner_id}/labels"],setGithubActionsDefaultWorkflowPermissionsOrganization:["PUT /orgs/{org}/actions/permissions/workflow"],setGithubActionsDefaultWorkflowPermissionsRepository:["PUT /repos/{owner}/{repo}/actions/permissions/workflow"],setGithubActionsPermissionsOrganization:["PUT /orgs/{org}/actions/permissions"],setGithubActionsPermissionsRepository:["PUT /repos/{owner}/{repo}/actions/permissions"],setSelectedReposForOrgSecret:["PUT /orgs/{org}/actions/secrets/{secret_name}/repositories"],setSelectedReposForOrgVariable:["PUT /orgs/{org}/actions/variables/{name}/repositories"],setSelectedRepositoriesEnabledGithubActionsOrganization:["PUT /orgs/{org}/actions/permissions/repositories"],setWorkflowAccessToRepository:["PUT /repos/{owner}/{repo}/actions/permissions/access"],updateEnvironmentVariable:["PATCH /repositories/{repository_id}/environments/{environment_name}/variables/{name}"],updateOrgVariable:["PATCH /orgs/{org}/actions/variables/{name}"],updateRepoVariable:["PATCH /repos/{owner}/{repo}/actions/variables/{name}"]},activity:{checkRepoIsStarredByAuthenticatedUser:["GET /user/starred/{owner}/{repo}"],deleteRepoSubscription:["DELETE /repos/{owner}/{repo}/subscription"],deleteThreadSubscription:["DELETE /notifications/threads/{thread_id}/subscription"],getFeeds:["GET /feeds"],getRepoSubscription:["GET /repos/{owner}/{repo}/subscription"],getThread:["GET /notifications/threads/{thread_id}"],getThreadSubscriptionForAuthenticatedUser:["GET /notifications/threads/{thread_id}/subscription"],listEventsForAuthenticatedUser:["GET /users/{username}/events"],listNotificationsForAuthenticatedUser:["GET /notifications"],listOrgEventsForAuthenticatedUser:["GET /users/{username}/events/orgs/{org}"],listPublicEvents:["GET /events"],listPublicEventsForRepoNetwork:["GET /networks/{owner}/{repo}/events"],listPublicEventsForUser:["GET /users/{username}/events/public"],listPublicOrgEvents:["GET /orgs/{org}/events"],listReceivedEventsForUser:["GET /users/{username}/received_events"],listReceivedPublicEventsForUser:["GET /users/{username}/received_events/public"],listRepoEvents:["GET /repos/{owner}/{repo}/events"],listRepoNotificationsForAuthenticatedUser:["GET /repos/{owner}/{repo}/notifications"],listReposStarredByAuthenticatedUser:["GET /user/starred"],listReposStarredByUser:["GET /users/{username}/starred"],listReposWatchedByUser:["GET /users/{username}/subscriptions"],listStargazersForRepo:["GET /repos/{owner}/{repo}/stargazers"],listWatchedReposForAuthenticatedUser:["GET /user/subscriptions"],listWatchersForRepo:["GET /repos/{owner}/{repo}/subscribers"],markNotificationsAsRead:["PUT /notifications"],markRepoNotificationsAsRead:["PUT /repos/{owner}/{repo}/notifications"],markThreadAsRead:["PATCH /notifications/threads/{thread_id}"],setRepoSubscription:["PUT /repos/{owner}/{repo}/subscription"],setThreadSubscription:["PUT /notifications/threads/{thread_id}/subscription"],starRepoForAuthenticatedUser:["PUT /user/starred/{owner}/{repo}"],unstarRepoForAuthenticatedUser:["DELETE /user/starred/{owner}/{repo}"]},apps:{addRepoToInstallation:["PUT /user/installations/{installation_id}/repositories/{repository_id}",{},{renamed:["apps","addRepoToInstallationForAuthenticatedUser"]}],addRepoToInstallationForAuthenticatedUser:["PUT /user/installations/{installation_id}/repositories/{repository_id}"],checkToken:["POST /applications/{client_id}/token"],createFromManifest:["POST /app-manifests/{code}/conversions"],createInstallationAccessToken:["POST /app/installations/{installation_id}/access_tokens"],deleteAuthorization:["DELETE /applications/{client_id}/grant"],deleteInstallation:["DELETE /app/installations/{installation_id}"],deleteToken:["DELETE /applications/{client_id}/token"],getAuthenticated:["GET /app"],getBySlug:["GET /apps/{app_slug}"],getInstallation:["GET /app/installations/{installation_id}"],getOrgInstallation:["GET /orgs/{org}/installation"],getRepoInstallation:["GET /repos/{owner}/{repo}/installation"],getSubscriptionPlanForAccount:["GET /marketplace_listing/accounts/{account_id}"],getSubscriptionPlanForAccountStubbed:["GET /marketplace_listing/stubbed/accounts/{account_id}"],getUserInstallation:["GET /users/{username}/installation"],getWebhookConfigForApp:["GET /app/hook/config"],getWebhookDelivery:["GET /app/hook/deliveries/{delivery_id}"],listAccountsForPlan:["GET /marketplace_listing/plans/{plan_id}/accounts"],listAccountsForPlanStubbed:["GET /marketplace_listing/stubbed/plans/{plan_id}/accounts"],listInstallationReposForAuthenticatedUser:["GET /user/installations/{installation_id}/repositories"],listInstallationRequestsForAuthenticatedApp:["GET /app/installation-requests"],listInstallations:["GET /app/installations"],listInstallationsForAuthenticatedUser:["GET /user/installations"],listPlans:["GET /marketplace_listing/plans"],listPlansStubbed:["GET /marketplace_listing/stubbed/plans"],listReposAccessibleToInstallation:["GET /installation/repositories"],listSubscriptionsForAuthenticatedUser:["GET /user/marketplace_purchases"],listSubscriptionsForAuthenticatedUserStubbed:["GET /user/marketplace_purchases/stubbed"],listWebhookDeliveries:["GET /app/hook/deliveries"],redeliverWebhookDelivery:["POST /app/hook/deliveries/{delivery_id}/attempts"],removeRepoFromInstallation:["DELETE /user/installations/{installation_id}/repositories/{repository_id}",{},{renamed:["apps","removeRepoFromInstallationForAuthenticatedUser"]}],removeRepoFromInstallationForAuthenticatedUser:["DELETE /user/installations/{installation_id}/repositories/{repository_id}"],resetToken:["PATCH /applications/{client_id}/token"],revokeInstallationAccessToken:["DELETE /installation/token"],scopeToken:["POST /applications/{client_id}/token/scoped"],suspendInstallation:["PUT /app/installations/{installation_id}/suspended"],unsuspendInstallation:["DELETE /app/installations/{installation_id}/suspended"],updateWebhookConfigForApp:["PATCH /app/hook/config"]},billing:{getGithubActionsBillingOrg:["GET /orgs/{org}/settings/billing/actions"],getGithubActionsBillingUser:["GET /users/{username}/settings/billing/actions"],getGithubPackagesBillingOrg:["GET /orgs/{org}/settings/billing/packages"],getGithubPackagesBillingUser:["GET /users/{username}/settings/billing/packages"],getSharedStorageBillingOrg:["GET /orgs/{org}/settings/billing/shared-storage"],getSharedStorageBillingUser:["GET /users/{username}/settings/billing/shared-storage"]},checks:{create:["POST /repos/{owner}/{repo}/check-runs"],createSuite:["POST /repos/{owner}/{repo}/check-suites"],get:["GET /repos/{owner}/{repo}/check-runs/{check_run_id}"],getSuite:["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}"],listAnnotations:["GET /repos/{owner}/{repo}/check-runs/{check_run_id}/annotations"],listForRef:["GET /repos/{owner}/{repo}/commits/{ref}/check-runs"],listForSuite:["GET /repos/{owner}/{repo}/check-suites/{check_suite_id}/check-runs"],listSuitesForRef:["GET /repos/{owner}/{repo}/commits/{ref}/check-suites"],rerequestRun:["POST /repos/{owner}/{repo}/check-runs/{check_run_id}/rerequest"],rerequestSuite:["POST /repos/{owner}/{repo}/check-suites/{check_suite_id}/rerequest"],setSuitesPreferences:["PATCH /repos/{owner}/{repo}/check-suites/preferences"],update:["PATCH /repos/{owner}/{repo}/check-runs/{check_run_id}"]},codeScanning:{deleteAnalysis:["DELETE /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}{?confirm_delete}"],getAlert:["GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}",{},{renamedParameters:{alert_id:"alert_number"}}],getAnalysis:["GET /repos/{owner}/{repo}/code-scanning/analyses/{analysis_id}"],getCodeqlDatabase:["GET /repos/{owner}/{repo}/code-scanning/codeql/databases/{language}"],getDefaultSetup:["GET /repos/{owner}/{repo}/code-scanning/default-setup"],getSarif:["GET /repos/{owner}/{repo}/code-scanning/sarifs/{sarif_id}"],listAlertInstances:["GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances"],listAlertsForOrg:["GET /orgs/{org}/code-scanning/alerts"],listAlertsForRepo:["GET /repos/{owner}/{repo}/code-scanning/alerts"],listAlertsInstances:["GET /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}/instances",{},{renamed:["codeScanning","listAlertInstances"]}],listCodeqlDatabases:["GET /repos/{owner}/{repo}/code-scanning/codeql/databases"],listRecentAnalyses:["GET /repos/{owner}/{repo}/code-scanning/analyses"],updateAlert:["PATCH /repos/{owner}/{repo}/code-scanning/alerts/{alert_number}"],updateDefaultSetup:["PATCH /repos/{owner}/{repo}/code-scanning/default-setup"],uploadSarif:["POST /repos/{owner}/{repo}/code-scanning/sarifs"]},codesOfConduct:{getAllCodesOfConduct:["GET /codes_of_conduct"],getConductCode:["GET /codes_of_conduct/{key}"]},codespaces:{addRepositoryForSecretForAuthenticatedUser:["PUT /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"],addSelectedRepoToOrgSecret:["PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"],checkPermissionsForDevcontainer:["GET /repos/{owner}/{repo}/codespaces/permissions_check"],codespaceMachinesForAuthenticatedUser:["GET /user/codespaces/{codespace_name}/machines"],createForAuthenticatedUser:["POST /user/codespaces"],createOrUpdateOrgSecret:["PUT /orgs/{org}/codespaces/secrets/{secret_name}"],createOrUpdateRepoSecret:["PUT /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"],createOrUpdateSecretForAuthenticatedUser:["PUT /user/codespaces/secrets/{secret_name}"],createWithPrForAuthenticatedUser:["POST /repos/{owner}/{repo}/pulls/{pull_number}/codespaces"],createWithRepoForAuthenticatedUser:["POST /repos/{owner}/{repo}/codespaces"],deleteForAuthenticatedUser:["DELETE /user/codespaces/{codespace_name}"],deleteFromOrganization:["DELETE /orgs/{org}/members/{username}/codespaces/{codespace_name}"],deleteOrgSecret:["DELETE /orgs/{org}/codespaces/secrets/{secret_name}"],deleteRepoSecret:["DELETE /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"],deleteSecretForAuthenticatedUser:["DELETE /user/codespaces/secrets/{secret_name}"],exportForAuthenticatedUser:["POST /user/codespaces/{codespace_name}/exports"],getCodespacesForUserInOrg:["GET /orgs/{org}/members/{username}/codespaces"],getExportDetailsForAuthenticatedUser:["GET /user/codespaces/{codespace_name}/exports/{export_id}"],getForAuthenticatedUser:["GET /user/codespaces/{codespace_name}"],getOrgPublicKey:["GET /orgs/{org}/codespaces/secrets/public-key"],getOrgSecret:["GET /orgs/{org}/codespaces/secrets/{secret_name}"],getPublicKeyForAuthenticatedUser:["GET /user/codespaces/secrets/public-key"],getRepoPublicKey:["GET /repos/{owner}/{repo}/codespaces/secrets/public-key"],getRepoSecret:["GET /repos/{owner}/{repo}/codespaces/secrets/{secret_name}"],getSecretForAuthenticatedUser:["GET /user/codespaces/secrets/{secret_name}"],listDevcontainersInRepositoryForAuthenticatedUser:["GET /repos/{owner}/{repo}/codespaces/devcontainers"],listForAuthenticatedUser:["GET /user/codespaces"],listInOrganization:["GET /orgs/{org}/codespaces",{},{renamedParameters:{org_id:"org"}}],listInRepositoryForAuthenticatedUser:["GET /repos/{owner}/{repo}/codespaces"],listOrgSecrets:["GET /orgs/{org}/codespaces/secrets"],listRepoSecrets:["GET /repos/{owner}/{repo}/codespaces/secrets"],listRepositoriesForSecretForAuthenticatedUser:["GET /user/codespaces/secrets/{secret_name}/repositories"],listSecretsForAuthenticatedUser:["GET /user/codespaces/secrets"],listSelectedReposForOrgSecret:["GET /orgs/{org}/codespaces/secrets/{secret_name}/repositories"],preFlightWithRepoForAuthenticatedUser:["GET /repos/{owner}/{repo}/codespaces/new"],publishForAuthenticatedUser:["POST /user/codespaces/{codespace_name}/publish"],removeRepositoryForSecretForAuthenticatedUser:["DELETE /user/codespaces/secrets/{secret_name}/repositories/{repository_id}"],removeSelectedRepoFromOrgSecret:["DELETE /orgs/{org}/codespaces/secrets/{secret_name}/repositories/{repository_id}"],repoMachinesForAuthenticatedUser:["GET /repos/{owner}/{repo}/codespaces/machines"],setRepositoriesForSecretForAuthenticatedUser:["PUT /user/codespaces/secrets/{secret_name}/repositories"],setSelectedReposForOrgSecret:["PUT /orgs/{org}/codespaces/secrets/{secret_name}/repositories"],startForAuthenticatedUser:["POST /user/codespaces/{codespace_name}/start"],stopForAuthenticatedUser:["POST /user/codespaces/{codespace_name}/stop"],stopInOrganization:["POST /orgs/{org}/members/{username}/codespaces/{codespace_name}/stop"],updateForAuthenticatedUser:["PATCH /user/codespaces/{codespace_name}"]},copilot:{addCopilotForBusinessSeatsForTeams:["POST /orgs/{org}/copilot/billing/selected_teams"],addCopilotForBusinessSeatsForUsers:["POST /orgs/{org}/copilot/billing/selected_users"],cancelCopilotSeatAssignmentForTeams:["DELETE /orgs/{org}/copilot/billing/selected_teams"],cancelCopilotSeatAssignmentForUsers:["DELETE /orgs/{org}/copilot/billing/selected_users"],getCopilotOrganizationDetails:["GET /orgs/{org}/copilot/billing"],getCopilotSeatDetailsForUser:["GET /orgs/{org}/members/{username}/copilot"],listCopilotSeats:["GET /orgs/{org}/copilot/billing/seats"]},dependabot:{addSelectedRepoToOrgSecret:["PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"],createOrUpdateOrgSecret:["PUT /orgs/{org}/dependabot/secrets/{secret_name}"],createOrUpdateRepoSecret:["PUT /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"],deleteOrgSecret:["DELETE /orgs/{org}/dependabot/secrets/{secret_name}"],deleteRepoSecret:["DELETE /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"],getAlert:["GET /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"],getOrgPublicKey:["GET /orgs/{org}/dependabot/secrets/public-key"],getOrgSecret:["GET /orgs/{org}/dependabot/secrets/{secret_name}"],getRepoPublicKey:["GET /repos/{owner}/{repo}/dependabot/secrets/public-key"],getRepoSecret:["GET /repos/{owner}/{repo}/dependabot/secrets/{secret_name}"],listAlertsForEnterprise:["GET /enterprises/{enterprise}/dependabot/alerts"],listAlertsForOrg:["GET /orgs/{org}/dependabot/alerts"],listAlertsForRepo:["GET /repos/{owner}/{repo}/dependabot/alerts"],listOrgSecrets:["GET /orgs/{org}/dependabot/secrets"],listRepoSecrets:["GET /repos/{owner}/{repo}/dependabot/secrets"],listSelectedReposForOrgSecret:["GET /orgs/{org}/dependabot/secrets/{secret_name}/repositories"],removeSelectedRepoFromOrgSecret:["DELETE /orgs/{org}/dependabot/secrets/{secret_name}/repositories/{repository_id}"],setSelectedReposForOrgSecret:["PUT /orgs/{org}/dependabot/secrets/{secret_name}/repositories"],updateAlert:["PATCH /repos/{owner}/{repo}/dependabot/alerts/{alert_number}"]},dependencyGraph:{createRepositorySnapshot:["POST /repos/{owner}/{repo}/dependency-graph/snapshots"],diffRange:["GET /repos/{owner}/{repo}/dependency-graph/compare/{basehead}"],exportSbom:["GET /repos/{owner}/{repo}/dependency-graph/sbom"]},emojis:{get:["GET /emojis"]},gists:{checkIsStarred:["GET /gists/{gist_id}/star"],create:["POST /gists"],createComment:["POST /gists/{gist_id}/comments"],delete:["DELETE /gists/{gist_id}"],deleteComment:["DELETE /gists/{gist_id}/comments/{comment_id}"],fork:["POST /gists/{gist_id}/forks"],get:["GET /gists/{gist_id}"],getComment:["GET /gists/{gist_id}/comments/{comment_id}"],getRevision:["GET /gists/{gist_id}/{sha}"],list:["GET /gists"],listComments:["GET /gists/{gist_id}/comments"],listCommits:["GET /gists/{gist_id}/commits"],listForUser:["GET /users/{username}/gists"],listForks:["GET /gists/{gist_id}/forks"],listPublic:["GET /gists/public"],listStarred:["GET /gists/starred"],star:["PUT /gists/{gist_id}/star"],unstar:["DELETE /gists/{gist_id}/star"],update:["PATCH /gists/{gist_id}"],updateComment:["PATCH /gists/{gist_id}/comments/{comment_id}"]},git:{createBlob:["POST /repos/{owner}/{repo}/git/blobs"],createCommit:["POST /repos/{owner}/{repo}/git/commits"],createRef:["POST /repos/{owner}/{repo}/git/refs"],createTag:["POST /repos/{owner}/{repo}/git/tags"],createTree:["POST /repos/{owner}/{repo}/git/trees"],deleteRef:["DELETE /repos/{owner}/{repo}/git/refs/{ref}"],getBlob:["GET /repos/{owner}/{repo}/git/blobs/{file_sha}"],getCommit:["GET /repos/{owner}/{repo}/git/commits/{commit_sha}"],getRef:["GET /repos/{owner}/{repo}/git/ref/{ref}"],getTag:["GET /repos/{owner}/{repo}/git/tags/{tag_sha}"],getTree:["GET /repos/{owner}/{repo}/git/trees/{tree_sha}"],listMatchingRefs:["GET /repos/{owner}/{repo}/git/matching-refs/{ref}"],updateRef:["PATCH /repos/{owner}/{repo}/git/refs/{ref}"]},gitignore:{getAllTemplates:["GET /gitignore/templates"],getTemplate:["GET /gitignore/templates/{name}"]},interactions:{getRestrictionsForAuthenticatedUser:["GET /user/interaction-limits"],getRestrictionsForOrg:["GET /orgs/{org}/interaction-limits"],getRestrictionsForRepo:["GET /repos/{owner}/{repo}/interaction-limits"],getRestrictionsForYourPublicRepos:["GET /user/interaction-limits",{},{renamed:["interactions","getRestrictionsForAuthenticatedUser"]}],removeRestrictionsForAuthenticatedUser:["DELETE /user/interaction-limits"],removeRestrictionsForOrg:["DELETE /orgs/{org}/interaction-limits"],removeRestrictionsForRepo:["DELETE /repos/{owner}/{repo}/interaction-limits"],removeRestrictionsForYourPublicRepos:["DELETE /user/interaction-limits",{},{renamed:["interactions","removeRestrictionsForAuthenticatedUser"]}],setRestrictionsForAuthenticatedUser:["PUT /user/interaction-limits"],setRestrictionsForOrg:["PUT /orgs/{org}/interaction-limits"],setRestrictionsForRepo:["PUT /repos/{owner}/{repo}/interaction-limits"],setRestrictionsForYourPublicRepos:["PUT /user/interaction-limits",{},{renamed:["interactions","setRestrictionsForAuthenticatedUser"]}]},issues:{addAssignees:["POST /repos/{owner}/{repo}/issues/{issue_number}/assignees"],addLabels:["POST /repos/{owner}/{repo}/issues/{issue_number}/labels"],checkUserCanBeAssigned:["GET /repos/{owner}/{repo}/assignees/{assignee}"],checkUserCanBeAssignedToIssue:["GET /repos/{owner}/{repo}/issues/{issue_number}/assignees/{assignee}"],create:["POST /repos/{owner}/{repo}/issues"],createComment:["POST /repos/{owner}/{repo}/issues/{issue_number}/comments"],createLabel:["POST /repos/{owner}/{repo}/labels"],createMilestone:["POST /repos/{owner}/{repo}/milestones"],deleteComment:["DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}"],deleteLabel:["DELETE /repos/{owner}/{repo}/labels/{name}"],deleteMilestone:["DELETE /repos/{owner}/{repo}/milestones/{milestone_number}"],get:["GET /repos/{owner}/{repo}/issues/{issue_number}"],getComment:["GET /repos/{owner}/{repo}/issues/comments/{comment_id}"],getEvent:["GET /repos/{owner}/{repo}/issues/events/{event_id}"],getLabel:["GET /repos/{owner}/{repo}/labels/{name}"],getMilestone:["GET /repos/{owner}/{repo}/milestones/{milestone_number}"],list:["GET /issues"],listAssignees:["GET /repos/{owner}/{repo}/assignees"],listComments:["GET /repos/{owner}/{repo}/issues/{issue_number}/comments"],listCommentsForRepo:["GET /repos/{owner}/{repo}/issues/comments"],listEvents:["GET /repos/{owner}/{repo}/issues/{issue_number}/events"],listEventsForRepo:["GET /repos/{owner}/{repo}/issues/events"],listEventsForTimeline:["GET /repos/{owner}/{repo}/issues/{issue_number}/timeline"],listForAuthenticatedUser:["GET /user/issues"],listForOrg:["GET /orgs/{org}/issues"],listForRepo:["GET /repos/{owner}/{repo}/issues"],listLabelsForMilestone:["GET /repos/{owner}/{repo}/milestones/{milestone_number}/labels"],listLabelsForRepo:["GET /repos/{owner}/{repo}/labels"],listLabelsOnIssue:["GET /repos/{owner}/{repo}/issues/{issue_number}/labels"],listMilestones:["GET /repos/{owner}/{repo}/milestones"],lock:["PUT /repos/{owner}/{repo}/issues/{issue_number}/lock"],removeAllLabels:["DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels"],removeAssignees:["DELETE /repos/{owner}/{repo}/issues/{issue_number}/assignees"],removeLabel:["DELETE /repos/{owner}/{repo}/issues/{issue_number}/labels/{name}"],setLabels:["PUT /repos/{owner}/{repo}/issues/{issue_number}/labels"],unlock:["DELETE /repos/{owner}/{repo}/issues/{issue_number}/lock"],update:["PATCH /repos/{owner}/{repo}/issues/{issue_number}"],updateComment:["PATCH /repos/{owner}/{repo}/issues/comments/{comment_id}"],updateLabel:["PATCH /repos/{owner}/{repo}/labels/{name}"],updateMilestone:["PATCH /repos/{owner}/{repo}/milestones/{milestone_number}"]},licenses:{get:["GET /licenses/{license}"],getAllCommonlyUsed:["GET /licenses"],getForRepo:["GET /repos/{owner}/{repo}/license"]},markdown:{render:["POST /markdown"],renderRaw:["POST /markdown/raw",{headers:{"content-type":"text/plain; charset=utf-8"}}]},meta:{get:["GET /meta"],getAllVersions:["GET /versions"],getOctocat:["GET /octocat"],getZen:["GET /zen"],root:["GET /"]},migrations:{cancelImport:["DELETE /repos/{owner}/{repo}/import",{},{deprecated:"octokit.rest.migrations.cancelImport() is deprecated, see https://docs.github.com/rest/migrations/source-imports#cancel-an-import"}],deleteArchiveForAuthenticatedUser:["DELETE /user/migrations/{migration_id}/archive"],deleteArchiveForOrg:["DELETE /orgs/{org}/migrations/{migration_id}/archive"],downloadArchiveForOrg:["GET /orgs/{org}/migrations/{migration_id}/archive"],getArchiveForAuthenticatedUser:["GET /user/migrations/{migration_id}/archive"],getCommitAuthors:["GET /repos/{owner}/{repo}/import/authors",{},{deprecated:"octokit.rest.migrations.getCommitAuthors() is deprecated, see https://docs.github.com/rest/migrations/source-imports#get-commit-authors"}],getImportStatus:["GET /repos/{owner}/{repo}/import",{},{deprecated:"octokit.rest.migrations.getImportStatus() is deprecated, see https://docs.github.com/rest/migrations/source-imports#get-an-import-status"}],getLargeFiles:["GET /repos/{owner}/{repo}/import/large_files",{},{deprecated:"octokit.rest.migrations.getLargeFiles() is deprecated, see https://docs.github.com/rest/migrations/source-imports#get-large-files"}],getStatusForAuthenticatedUser:["GET /user/migrations/{migration_id}"],getStatusForOrg:["GET /orgs/{org}/migrations/{migration_id}"],listForAuthenticatedUser:["GET /user/migrations"],listForOrg:["GET /orgs/{org}/migrations"],listReposForAuthenticatedUser:["GET /user/migrations/{migration_id}/repositories"],listReposForOrg:["GET /orgs/{org}/migrations/{migration_id}/repositories"],listReposForUser:["GET /user/migrations/{migration_id}/repositories",{},{renamed:["migrations","listReposForAuthenticatedUser"]}],mapCommitAuthor:["PATCH /repos/{owner}/{repo}/import/authors/{author_id}",{},{deprecated:"octokit.rest.migrations.mapCommitAuthor() is deprecated, see https://docs.github.com/rest/migrations/source-imports#map-a-commit-author"}],setLfsPreference:["PATCH /repos/{owner}/{repo}/import/lfs",{},{deprecated:"octokit.rest.migrations.setLfsPreference() is deprecated, see https://docs.github.com/rest/migrations/source-imports#update-git-lfs-preference"}],startForAuthenticatedUser:["POST /user/migrations"],startForOrg:["POST /orgs/{org}/migrations"],startImport:["PUT /repos/{owner}/{repo}/import",{},{deprecated:"octokit.rest.migrations.startImport() is deprecated, see https://docs.github.com/rest/migrations/source-imports#start-an-import"}],unlockRepoForAuthenticatedUser:["DELETE /user/migrations/{migration_id}/repos/{repo_name}/lock"],unlockRepoForOrg:["DELETE /orgs/{org}/migrations/{migration_id}/repos/{repo_name}/lock"],updateImport:["PATCH /repos/{owner}/{repo}/import",{},{deprecated:"octokit.rest.migrations.updateImport() is deprecated, see https://docs.github.com/rest/migrations/source-imports#update-an-import"}]},orgs:{addSecurityManagerTeam:["PUT /orgs/{org}/security-managers/teams/{team_slug}"],blockUser:["PUT /orgs/{org}/blocks/{username}"],cancelInvitation:["DELETE /orgs/{org}/invitations/{invitation_id}"],checkBlockedUser:["GET /orgs/{org}/blocks/{username}"],checkMembershipForUser:["GET /orgs/{org}/members/{username}"],checkPublicMembershipForUser:["GET /orgs/{org}/public_members/{username}"],convertMemberToOutsideCollaborator:["PUT /orgs/{org}/outside_collaborators/{username}"],createInvitation:["POST /orgs/{org}/invitations"],createOrUpdateCustomProperties:["PATCH /orgs/{org}/properties/schema"],createOrUpdateCustomPropertiesValuesForRepos:["PATCH /orgs/{org}/properties/values"],createOrUpdateCustomProperty:["PUT /orgs/{org}/properties/schema/{custom_property_name}"],createWebhook:["POST /orgs/{org}/hooks"],delete:["DELETE /orgs/{org}"],deleteWebhook:["DELETE /orgs/{org}/hooks/{hook_id}"],enableOrDisableSecurityProductOnAllOrgRepos:["POST /orgs/{org}/{security_product}/{enablement}"],get:["GET /orgs/{org}"],getAllCustomProperties:["GET /orgs/{org}/properties/schema"],getCustomProperty:["GET /orgs/{org}/properties/schema/{custom_property_name}"],getMembershipForAuthenticatedUser:["GET /user/memberships/orgs/{org}"],getMembershipForUser:["GET /orgs/{org}/memberships/{username}"],getWebhook:["GET /orgs/{org}/hooks/{hook_id}"],getWebhookConfigForOrg:["GET /orgs/{org}/hooks/{hook_id}/config"],getWebhookDelivery:["GET /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}"],list:["GET /organizations"],listAppInstallations:["GET /orgs/{org}/installations"],listBlockedUsers:["GET /orgs/{org}/blocks"],listCustomPropertiesValuesForRepos:["GET /orgs/{org}/properties/values"],listFailedInvitations:["GET /orgs/{org}/failed_invitations"],listForAuthenticatedUser:["GET /user/orgs"],listForUser:["GET /users/{username}/orgs"],listInvitationTeams:["GET /orgs/{org}/invitations/{invitation_id}/teams"],listMembers:["GET /orgs/{org}/members"],listMembershipsForAuthenticatedUser:["GET /user/memberships/orgs"],listOutsideCollaborators:["GET /orgs/{org}/outside_collaborators"],listPatGrantRepositories:["GET /orgs/{org}/personal-access-tokens/{pat_id}/repositories"],listPatGrantRequestRepositories:["GET /orgs/{org}/personal-access-token-requests/{pat_request_id}/repositories"],listPatGrantRequests:["GET /orgs/{org}/personal-access-token-requests"],listPatGrants:["GET /orgs/{org}/personal-access-tokens"],listPendingInvitations:["GET /orgs/{org}/invitations"],listPublicMembers:["GET /orgs/{org}/public_members"],listSecurityManagerTeams:["GET /orgs/{org}/security-managers"],listWebhookDeliveries:["GET /orgs/{org}/hooks/{hook_id}/deliveries"],listWebhooks:["GET /orgs/{org}/hooks"],pingWebhook:["POST /orgs/{org}/hooks/{hook_id}/pings"],redeliverWebhookDelivery:["POST /orgs/{org}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"],removeCustomProperty:["DELETE /orgs/{org}/properties/schema/{custom_property_name}"],removeMember:["DELETE /orgs/{org}/members/{username}"],removeMembershipForUser:["DELETE /orgs/{org}/memberships/{username}"],removeOutsideCollaborator:["DELETE /orgs/{org}/outside_collaborators/{username}"],removePublicMembershipForAuthenticatedUser:["DELETE /orgs/{org}/public_members/{username}"],removeSecurityManagerTeam:["DELETE /orgs/{org}/security-managers/teams/{team_slug}"],reviewPatGrantRequest:["POST /orgs/{org}/personal-access-token-requests/{pat_request_id}"],reviewPatGrantRequestsInBulk:["POST /orgs/{org}/personal-access-token-requests"],setMembershipForUser:["PUT /orgs/{org}/memberships/{username}"],setPublicMembershipForAuthenticatedUser:["PUT /orgs/{org}/public_members/{username}"],unblockUser:["DELETE /orgs/{org}/blocks/{username}"],update:["PATCH /orgs/{org}"],updateMembershipForAuthenticatedUser:["PATCH /user/memberships/orgs/{org}"],updatePatAccess:["POST /orgs/{org}/personal-access-tokens/{pat_id}"],updatePatAccesses:["POST /orgs/{org}/personal-access-tokens"],updateWebhook:["PATCH /orgs/{org}/hooks/{hook_id}"],updateWebhookConfigForOrg:["PATCH /orgs/{org}/hooks/{hook_id}/config"]},packages:{deletePackageForAuthenticatedUser:["DELETE /user/packages/{package_type}/{package_name}"],deletePackageForOrg:["DELETE /orgs/{org}/packages/{package_type}/{package_name}"],deletePackageForUser:["DELETE /users/{username}/packages/{package_type}/{package_name}"],deletePackageVersionForAuthenticatedUser:["DELETE /user/packages/{package_type}/{package_name}/versions/{package_version_id}"],deletePackageVersionForOrg:["DELETE /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"],deletePackageVersionForUser:["DELETE /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"],getAllPackageVersionsForAPackageOwnedByAnOrg:["GET /orgs/{org}/packages/{package_type}/{package_name}/versions",{},{renamed:["packages","getAllPackageVersionsForPackageOwnedByOrg"]}],getAllPackageVersionsForAPackageOwnedByTheAuthenticatedUser:["GET /user/packages/{package_type}/{package_name}/versions",{},{renamed:["packages","getAllPackageVersionsForPackageOwnedByAuthenticatedUser"]}],getAllPackageVersionsForPackageOwnedByAuthenticatedUser:["GET /user/packages/{package_type}/{package_name}/versions"],getAllPackageVersionsForPackageOwnedByOrg:["GET /orgs/{org}/packages/{package_type}/{package_name}/versions"],getAllPackageVersionsForPackageOwnedByUser:["GET /users/{username}/packages/{package_type}/{package_name}/versions"],getPackageForAuthenticatedUser:["GET /user/packages/{package_type}/{package_name}"],getPackageForOrganization:["GET /orgs/{org}/packages/{package_type}/{package_name}"],getPackageForUser:["GET /users/{username}/packages/{package_type}/{package_name}"],getPackageVersionForAuthenticatedUser:["GET /user/packages/{package_type}/{package_name}/versions/{package_version_id}"],getPackageVersionForOrganization:["GET /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}"],getPackageVersionForUser:["GET /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}"],listDockerMigrationConflictingPackagesForAuthenticatedUser:["GET /user/docker/conflicts"],listDockerMigrationConflictingPackagesForOrganization:["GET /orgs/{org}/docker/conflicts"],listDockerMigrationConflictingPackagesForUser:["GET /users/{username}/docker/conflicts"],listPackagesForAuthenticatedUser:["GET /user/packages"],listPackagesForOrganization:["GET /orgs/{org}/packages"],listPackagesForUser:["GET /users/{username}/packages"],restorePackageForAuthenticatedUser:["POST /user/packages/{package_type}/{package_name}/restore{?token}"],restorePackageForOrg:["POST /orgs/{org}/packages/{package_type}/{package_name}/restore{?token}"],restorePackageForUser:["POST /users/{username}/packages/{package_type}/{package_name}/restore{?token}"],restorePackageVersionForAuthenticatedUser:["POST /user/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"],restorePackageVersionForOrg:["POST /orgs/{org}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"],restorePackageVersionForUser:["POST /users/{username}/packages/{package_type}/{package_name}/versions/{package_version_id}/restore"]},projects:{addCollaborator:["PUT /projects/{project_id}/collaborators/{username}"],createCard:["POST /projects/columns/{column_id}/cards"],createColumn:["POST /projects/{project_id}/columns"],createForAuthenticatedUser:["POST /user/projects"],createForOrg:["POST /orgs/{org}/projects"],createForRepo:["POST /repos/{owner}/{repo}/projects"],delete:["DELETE /projects/{project_id}"],deleteCard:["DELETE /projects/columns/cards/{card_id}"],deleteColumn:["DELETE /projects/columns/{column_id}"],get:["GET /projects/{project_id}"],getCard:["GET /projects/columns/cards/{card_id}"],getColumn:["GET /projects/columns/{column_id}"],getPermissionForUser:["GET /projects/{project_id}/collaborators/{username}/permission"],listCards:["GET /projects/columns/{column_id}/cards"],listCollaborators:["GET /projects/{project_id}/collaborators"],listColumns:["GET /projects/{project_id}/columns"],listForOrg:["GET /orgs/{org}/projects"],listForRepo:["GET /repos/{owner}/{repo}/projects"],listForUser:["GET /users/{username}/projects"],moveCard:["POST /projects/columns/cards/{card_id}/moves"],moveColumn:["POST /projects/columns/{column_id}/moves"],removeCollaborator:["DELETE /projects/{project_id}/collaborators/{username}"],update:["PATCH /projects/{project_id}"],updateCard:["PATCH /projects/columns/cards/{card_id}"],updateColumn:["PATCH /projects/columns/{column_id}"]},pulls:{checkIfMerged:["GET /repos/{owner}/{repo}/pulls/{pull_number}/merge"],create:["POST /repos/{owner}/{repo}/pulls"],createReplyForReviewComment:["POST /repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies"],createReview:["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],createReviewComment:["POST /repos/{owner}/{repo}/pulls/{pull_number}/comments"],deletePendingReview:["DELETE /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"],deleteReviewComment:["DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}"],dismissReview:["PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/dismissals"],get:["GET /repos/{owner}/{repo}/pulls/{pull_number}"],getReview:["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"],getReviewComment:["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}"],list:["GET /repos/{owner}/{repo}/pulls"],listCommentsForReview:["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/comments"],listCommits:["GET /repos/{owner}/{repo}/pulls/{pull_number}/commits"],listFiles:["GET /repos/{owner}/{repo}/pulls/{pull_number}/files"],listRequestedReviewers:["GET /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"],listReviewComments:["GET /repos/{owner}/{repo}/pulls/{pull_number}/comments"],listReviewCommentsForRepo:["GET /repos/{owner}/{repo}/pulls/comments"],listReviews:["GET /repos/{owner}/{repo}/pulls/{pull_number}/reviews"],merge:["PUT /repos/{owner}/{repo}/pulls/{pull_number}/merge"],removeRequestedReviewers:["DELETE /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"],requestReviewers:["POST /repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers"],submitReview:["POST /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}/events"],update:["PATCH /repos/{owner}/{repo}/pulls/{pull_number}"],updateBranch:["PUT /repos/{owner}/{repo}/pulls/{pull_number}/update-branch"],updateReview:["PUT /repos/{owner}/{repo}/pulls/{pull_number}/reviews/{review_id}"],updateReviewComment:["PATCH /repos/{owner}/{repo}/pulls/comments/{comment_id}"]},rateLimit:{get:["GET /rate_limit"]},reactions:{createForCommitComment:["POST /repos/{owner}/{repo}/comments/{comment_id}/reactions"],createForIssue:["POST /repos/{owner}/{repo}/issues/{issue_number}/reactions"],createForIssueComment:["POST /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"],createForPullRequestReviewComment:["POST /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"],createForRelease:["POST /repos/{owner}/{repo}/releases/{release_id}/reactions"],createForTeamDiscussionCommentInOrg:["POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"],createForTeamDiscussionInOrg:["POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"],deleteForCommitComment:["DELETE /repos/{owner}/{repo}/comments/{comment_id}/reactions/{reaction_id}"],deleteForIssue:["DELETE /repos/{owner}/{repo}/issues/{issue_number}/reactions/{reaction_id}"],deleteForIssueComment:["DELETE /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions/{reaction_id}"],deleteForPullRequestComment:["DELETE /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions/{reaction_id}"],deleteForRelease:["DELETE /repos/{owner}/{repo}/releases/{release_id}/reactions/{reaction_id}"],deleteForTeamDiscussion:["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions/{reaction_id}"],deleteForTeamDiscussionComment:["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions/{reaction_id}"],listForCommitComment:["GET /repos/{owner}/{repo}/comments/{comment_id}/reactions"],listForIssue:["GET /repos/{owner}/{repo}/issues/{issue_number}/reactions"],listForIssueComment:["GET /repos/{owner}/{repo}/issues/comments/{comment_id}/reactions"],listForPullRequestReviewComment:["GET /repos/{owner}/{repo}/pulls/comments/{comment_id}/reactions"],listForRelease:["GET /repos/{owner}/{repo}/releases/{release_id}/reactions"],listForTeamDiscussionCommentInOrg:["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}/reactions"],listForTeamDiscussionInOrg:["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/reactions"]},repos:{acceptInvitation:["PATCH /user/repository_invitations/{invitation_id}",{},{renamed:["repos","acceptInvitationForAuthenticatedUser"]}],acceptInvitationForAuthenticatedUser:["PATCH /user/repository_invitations/{invitation_id}"],addAppAccessRestrictions:["POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",{},{mapToData:"apps"}],addCollaborator:["PUT /repos/{owner}/{repo}/collaborators/{username}"],addStatusCheckContexts:["POST /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",{},{mapToData:"contexts"}],addTeamAccessRestrictions:["POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",{},{mapToData:"teams"}],addUserAccessRestrictions:["POST /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",{},{mapToData:"users"}],checkAutomatedSecurityFixes:["GET /repos/{owner}/{repo}/automated-security-fixes"],checkCollaborator:["GET /repos/{owner}/{repo}/collaborators/{username}"],checkVulnerabilityAlerts:["GET /repos/{owner}/{repo}/vulnerability-alerts"],codeownersErrors:["GET /repos/{owner}/{repo}/codeowners/errors"],compareCommits:["GET /repos/{owner}/{repo}/compare/{base}...{head}"],compareCommitsWithBasehead:["GET /repos/{owner}/{repo}/compare/{basehead}"],createAutolink:["POST /repos/{owner}/{repo}/autolinks"],createCommitComment:["POST /repos/{owner}/{repo}/commits/{commit_sha}/comments"],createCommitSignatureProtection:["POST /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"],createCommitStatus:["POST /repos/{owner}/{repo}/statuses/{sha}"],createDeployKey:["POST /repos/{owner}/{repo}/keys"],createDeployment:["POST /repos/{owner}/{repo}/deployments"],createDeploymentBranchPolicy:["POST /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"],createDeploymentProtectionRule:["POST /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"],createDeploymentStatus:["POST /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"],createDispatchEvent:["POST /repos/{owner}/{repo}/dispatches"],createForAuthenticatedUser:["POST /user/repos"],createFork:["POST /repos/{owner}/{repo}/forks"],createInOrg:["POST /orgs/{org}/repos"],createOrUpdateEnvironment:["PUT /repos/{owner}/{repo}/environments/{environment_name}"],createOrUpdateFileContents:["PUT /repos/{owner}/{repo}/contents/{path}"],createOrgRuleset:["POST /orgs/{org}/rulesets"],createPagesDeployment:["POST /repos/{owner}/{repo}/pages/deployment"],createPagesSite:["POST /repos/{owner}/{repo}/pages"],createRelease:["POST /repos/{owner}/{repo}/releases"],createRepoRuleset:["POST /repos/{owner}/{repo}/rulesets"],createTagProtection:["POST /repos/{owner}/{repo}/tags/protection"],createUsingTemplate:["POST /repos/{template_owner}/{template_repo}/generate"],createWebhook:["POST /repos/{owner}/{repo}/hooks"],declineInvitation:["DELETE /user/repository_invitations/{invitation_id}",{},{renamed:["repos","declineInvitationForAuthenticatedUser"]}],declineInvitationForAuthenticatedUser:["DELETE /user/repository_invitations/{invitation_id}"],delete:["DELETE /repos/{owner}/{repo}"],deleteAccessRestrictions:["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"],deleteAdminBranchProtection:["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"],deleteAnEnvironment:["DELETE /repos/{owner}/{repo}/environments/{environment_name}"],deleteAutolink:["DELETE /repos/{owner}/{repo}/autolinks/{autolink_id}"],deleteBranchProtection:["DELETE /repos/{owner}/{repo}/branches/{branch}/protection"],deleteCommitComment:["DELETE /repos/{owner}/{repo}/comments/{comment_id}"],deleteCommitSignatureProtection:["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"],deleteDeployKey:["DELETE /repos/{owner}/{repo}/keys/{key_id}"],deleteDeployment:["DELETE /repos/{owner}/{repo}/deployments/{deployment_id}"],deleteDeploymentBranchPolicy:["DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"],deleteFile:["DELETE /repos/{owner}/{repo}/contents/{path}"],deleteInvitation:["DELETE /repos/{owner}/{repo}/invitations/{invitation_id}"],deleteOrgRuleset:["DELETE /orgs/{org}/rulesets/{ruleset_id}"],deletePagesSite:["DELETE /repos/{owner}/{repo}/pages"],deletePullRequestReviewProtection:["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"],deleteRelease:["DELETE /repos/{owner}/{repo}/releases/{release_id}"],deleteReleaseAsset:["DELETE /repos/{owner}/{repo}/releases/assets/{asset_id}"],deleteRepoRuleset:["DELETE /repos/{owner}/{repo}/rulesets/{ruleset_id}"],deleteTagProtection:["DELETE /repos/{owner}/{repo}/tags/protection/{tag_protection_id}"],deleteWebhook:["DELETE /repos/{owner}/{repo}/hooks/{hook_id}"],disableAutomatedSecurityFixes:["DELETE /repos/{owner}/{repo}/automated-security-fixes"],disableDeploymentProtectionRule:["DELETE /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"],disablePrivateVulnerabilityReporting:["DELETE /repos/{owner}/{repo}/private-vulnerability-reporting"],disableVulnerabilityAlerts:["DELETE /repos/{owner}/{repo}/vulnerability-alerts"],downloadArchive:["GET /repos/{owner}/{repo}/zipball/{ref}",{},{renamed:["repos","downloadZipballArchive"]}],downloadTarballArchive:["GET /repos/{owner}/{repo}/tarball/{ref}"],downloadZipballArchive:["GET /repos/{owner}/{repo}/zipball/{ref}"],enableAutomatedSecurityFixes:["PUT /repos/{owner}/{repo}/automated-security-fixes"],enablePrivateVulnerabilityReporting:["PUT /repos/{owner}/{repo}/private-vulnerability-reporting"],enableVulnerabilityAlerts:["PUT /repos/{owner}/{repo}/vulnerability-alerts"],generateReleaseNotes:["POST /repos/{owner}/{repo}/releases/generate-notes"],get:["GET /repos/{owner}/{repo}"],getAccessRestrictions:["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions"],getAdminBranchProtection:["GET /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"],getAllDeploymentProtectionRules:["GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules"],getAllEnvironments:["GET /repos/{owner}/{repo}/environments"],getAllStatusCheckContexts:["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts"],getAllTopics:["GET /repos/{owner}/{repo}/topics"],getAppsWithAccessToProtectedBranch:["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps"],getAutolink:["GET /repos/{owner}/{repo}/autolinks/{autolink_id}"],getBranch:["GET /repos/{owner}/{repo}/branches/{branch}"],getBranchProtection:["GET /repos/{owner}/{repo}/branches/{branch}/protection"],getBranchRules:["GET /repos/{owner}/{repo}/rules/branches/{branch}"],getClones:["GET /repos/{owner}/{repo}/traffic/clones"],getCodeFrequencyStats:["GET /repos/{owner}/{repo}/stats/code_frequency"],getCollaboratorPermissionLevel:["GET /repos/{owner}/{repo}/collaborators/{username}/permission"],getCombinedStatusForRef:["GET /repos/{owner}/{repo}/commits/{ref}/status"],getCommit:["GET /repos/{owner}/{repo}/commits/{ref}"],getCommitActivityStats:["GET /repos/{owner}/{repo}/stats/commit_activity"],getCommitComment:["GET /repos/{owner}/{repo}/comments/{comment_id}"],getCommitSignatureProtection:["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_signatures"],getCommunityProfileMetrics:["GET /repos/{owner}/{repo}/community/profile"],getContent:["GET /repos/{owner}/{repo}/contents/{path}"],getContributorsStats:["GET /repos/{owner}/{repo}/stats/contributors"],getCustomDeploymentProtectionRule:["GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/{protection_rule_id}"],getCustomPropertiesValues:["GET /repos/{owner}/{repo}/properties/values"],getDeployKey:["GET /repos/{owner}/{repo}/keys/{key_id}"],getDeployment:["GET /repos/{owner}/{repo}/deployments/{deployment_id}"],getDeploymentBranchPolicy:["GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"],getDeploymentStatus:["GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses/{status_id}"],getEnvironment:["GET /repos/{owner}/{repo}/environments/{environment_name}"],getLatestPagesBuild:["GET /repos/{owner}/{repo}/pages/builds/latest"],getLatestRelease:["GET /repos/{owner}/{repo}/releases/latest"],getOrgRuleSuite:["GET /orgs/{org}/rulesets/rule-suites/{rule_suite_id}"],getOrgRuleSuites:["GET /orgs/{org}/rulesets/rule-suites"],getOrgRuleset:["GET /orgs/{org}/rulesets/{ruleset_id}"],getOrgRulesets:["GET /orgs/{org}/rulesets"],getPages:["GET /repos/{owner}/{repo}/pages"],getPagesBuild:["GET /repos/{owner}/{repo}/pages/builds/{build_id}"],getPagesHealthCheck:["GET /repos/{owner}/{repo}/pages/health"],getParticipationStats:["GET /repos/{owner}/{repo}/stats/participation"],getPullRequestReviewProtection:["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"],getPunchCardStats:["GET /repos/{owner}/{repo}/stats/punch_card"],getReadme:["GET /repos/{owner}/{repo}/readme"],getReadmeInDirectory:["GET /repos/{owner}/{repo}/readme/{dir}"],getRelease:["GET /repos/{owner}/{repo}/releases/{release_id}"],getReleaseAsset:["GET /repos/{owner}/{repo}/releases/assets/{asset_id}"],getReleaseByTag:["GET /repos/{owner}/{repo}/releases/tags/{tag}"],getRepoRuleSuite:["GET /repos/{owner}/{repo}/rulesets/rule-suites/{rule_suite_id}"],getRepoRuleSuites:["GET /repos/{owner}/{repo}/rulesets/rule-suites"],getRepoRuleset:["GET /repos/{owner}/{repo}/rulesets/{ruleset_id}"],getRepoRulesets:["GET /repos/{owner}/{repo}/rulesets"],getStatusChecksProtection:["GET /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"],getTeamsWithAccessToProtectedBranch:["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams"],getTopPaths:["GET /repos/{owner}/{repo}/traffic/popular/paths"],getTopReferrers:["GET /repos/{owner}/{repo}/traffic/popular/referrers"],getUsersWithAccessToProtectedBranch:["GET /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users"],getViews:["GET /repos/{owner}/{repo}/traffic/views"],getWebhook:["GET /repos/{owner}/{repo}/hooks/{hook_id}"],getWebhookConfigForRepo:["GET /repos/{owner}/{repo}/hooks/{hook_id}/config"],getWebhookDelivery:["GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}"],listActivities:["GET /repos/{owner}/{repo}/activity"],listAutolinks:["GET /repos/{owner}/{repo}/autolinks"],listBranches:["GET /repos/{owner}/{repo}/branches"],listBranchesForHeadCommit:["GET /repos/{owner}/{repo}/commits/{commit_sha}/branches-where-head"],listCollaborators:["GET /repos/{owner}/{repo}/collaborators"],listCommentsForCommit:["GET /repos/{owner}/{repo}/commits/{commit_sha}/comments"],listCommitCommentsForRepo:["GET /repos/{owner}/{repo}/comments"],listCommitStatusesForRef:["GET /repos/{owner}/{repo}/commits/{ref}/statuses"],listCommits:["GET /repos/{owner}/{repo}/commits"],listContributors:["GET /repos/{owner}/{repo}/contributors"],listCustomDeploymentRuleIntegrations:["GET /repos/{owner}/{repo}/environments/{environment_name}/deployment_protection_rules/apps"],listDeployKeys:["GET /repos/{owner}/{repo}/keys"],listDeploymentBranchPolicies:["GET /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies"],listDeploymentStatuses:["GET /repos/{owner}/{repo}/deployments/{deployment_id}/statuses"],listDeployments:["GET /repos/{owner}/{repo}/deployments"],listForAuthenticatedUser:["GET /user/repos"],listForOrg:["GET /orgs/{org}/repos"],listForUser:["GET /users/{username}/repos"],listForks:["GET /repos/{owner}/{repo}/forks"],listInvitations:["GET /repos/{owner}/{repo}/invitations"],listInvitationsForAuthenticatedUser:["GET /user/repository_invitations"],listLanguages:["GET /repos/{owner}/{repo}/languages"],listPagesBuilds:["GET /repos/{owner}/{repo}/pages/builds"],listPublic:["GET /repositories"],listPullRequestsAssociatedWithCommit:["GET /repos/{owner}/{repo}/commits/{commit_sha}/pulls"],listReleaseAssets:["GET /repos/{owner}/{repo}/releases/{release_id}/assets"],listReleases:["GET /repos/{owner}/{repo}/releases"],listTagProtection:["GET /repos/{owner}/{repo}/tags/protection"],listTags:["GET /repos/{owner}/{repo}/tags"],listTeams:["GET /repos/{owner}/{repo}/teams"],listWebhookDeliveries:["GET /repos/{owner}/{repo}/hooks/{hook_id}/deliveries"],listWebhooks:["GET /repos/{owner}/{repo}/hooks"],merge:["POST /repos/{owner}/{repo}/merges"],mergeUpstream:["POST /repos/{owner}/{repo}/merge-upstream"],pingWebhook:["POST /repos/{owner}/{repo}/hooks/{hook_id}/pings"],redeliverWebhookDelivery:["POST /repos/{owner}/{repo}/hooks/{hook_id}/deliveries/{delivery_id}/attempts"],removeAppAccessRestrictions:["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",{},{mapToData:"apps"}],removeCollaborator:["DELETE /repos/{owner}/{repo}/collaborators/{username}"],removeStatusCheckContexts:["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",{},{mapToData:"contexts"}],removeStatusCheckProtection:["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"],removeTeamAccessRestrictions:["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",{},{mapToData:"teams"}],removeUserAccessRestrictions:["DELETE /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",{},{mapToData:"users"}],renameBranch:["POST /repos/{owner}/{repo}/branches/{branch}/rename"],replaceAllTopics:["PUT /repos/{owner}/{repo}/topics"],requestPagesBuild:["POST /repos/{owner}/{repo}/pages/builds"],setAdminBranchProtection:["POST /repos/{owner}/{repo}/branches/{branch}/protection/enforce_admins"],setAppAccessRestrictions:["PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/apps",{},{mapToData:"apps"}],setStatusCheckContexts:["PUT /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks/contexts",{},{mapToData:"contexts"}],setTeamAccessRestrictions:["PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/teams",{},{mapToData:"teams"}],setUserAccessRestrictions:["PUT /repos/{owner}/{repo}/branches/{branch}/protection/restrictions/users",{},{mapToData:"users"}],testPushWebhook:["POST /repos/{owner}/{repo}/hooks/{hook_id}/tests"],transfer:["POST /repos/{owner}/{repo}/transfer"],update:["PATCH /repos/{owner}/{repo}"],updateBranchProtection:["PUT /repos/{owner}/{repo}/branches/{branch}/protection"],updateCommitComment:["PATCH /repos/{owner}/{repo}/comments/{comment_id}"],updateDeploymentBranchPolicy:["PUT /repos/{owner}/{repo}/environments/{environment_name}/deployment-branch-policies/{branch_policy_id}"],updateInformationAboutPagesSite:["PUT /repos/{owner}/{repo}/pages"],updateInvitation:["PATCH /repos/{owner}/{repo}/invitations/{invitation_id}"],updateOrgRuleset:["PUT /orgs/{org}/rulesets/{ruleset_id}"],updatePullRequestReviewProtection:["PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_pull_request_reviews"],updateRelease:["PATCH /repos/{owner}/{repo}/releases/{release_id}"],updateReleaseAsset:["PATCH /repos/{owner}/{repo}/releases/assets/{asset_id}"],updateRepoRuleset:["PUT /repos/{owner}/{repo}/rulesets/{ruleset_id}"],updateStatusCheckPotection:["PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks",{},{renamed:["repos","updateStatusCheckProtection"]}],updateStatusCheckProtection:["PATCH /repos/{owner}/{repo}/branches/{branch}/protection/required_status_checks"],updateWebhook:["PATCH /repos/{owner}/{repo}/hooks/{hook_id}"],updateWebhookConfigForRepo:["PATCH /repos/{owner}/{repo}/hooks/{hook_id}/config"],uploadReleaseAsset:["POST /repos/{owner}/{repo}/releases/{release_id}/assets{?name,label}",{baseUrl:"https://uploads.github.com"}]},search:{code:["GET /search/code"],commits:["GET /search/commits"],issuesAndPullRequests:["GET /search/issues"],labels:["GET /search/labels"],repos:["GET /search/repositories"],topics:["GET /search/topics"],users:["GET /search/users"]},secretScanning:{getAlert:["GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"],listAlertsForEnterprise:["GET /enterprises/{enterprise}/secret-scanning/alerts"],listAlertsForOrg:["GET /orgs/{org}/secret-scanning/alerts"],listAlertsForRepo:["GET /repos/{owner}/{repo}/secret-scanning/alerts"],listLocationsForAlert:["GET /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}/locations"],updateAlert:["PATCH /repos/{owner}/{repo}/secret-scanning/alerts/{alert_number}"]},securityAdvisories:{createPrivateVulnerabilityReport:["POST /repos/{owner}/{repo}/security-advisories/reports"],createRepositoryAdvisory:["POST /repos/{owner}/{repo}/security-advisories"],createRepositoryAdvisoryCveRequest:["POST /repos/{owner}/{repo}/security-advisories/{ghsa_id}/cve"],getGlobalAdvisory:["GET /advisories/{ghsa_id}"],getRepositoryAdvisory:["GET /repos/{owner}/{repo}/security-advisories/{ghsa_id}"],listGlobalAdvisories:["GET /advisories"],listOrgRepositoryAdvisories:["GET /orgs/{org}/security-advisories"],listRepositoryAdvisories:["GET /repos/{owner}/{repo}/security-advisories"],updateRepositoryAdvisory:["PATCH /repos/{owner}/{repo}/security-advisories/{ghsa_id}"]},teams:{addOrUpdateMembershipForUserInOrg:["PUT /orgs/{org}/teams/{team_slug}/memberships/{username}"],addOrUpdateProjectPermissionsInOrg:["PUT /orgs/{org}/teams/{team_slug}/projects/{project_id}"],addOrUpdateRepoPermissionsInOrg:["PUT /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"],checkPermissionsForProjectInOrg:["GET /orgs/{org}/teams/{team_slug}/projects/{project_id}"],checkPermissionsForRepoInOrg:["GET /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"],create:["POST /orgs/{org}/teams"],createDiscussionCommentInOrg:["POST /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"],createDiscussionInOrg:["POST /orgs/{org}/teams/{team_slug}/discussions"],deleteDiscussionCommentInOrg:["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"],deleteDiscussionInOrg:["DELETE /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"],deleteInOrg:["DELETE /orgs/{org}/teams/{team_slug}"],getByName:["GET /orgs/{org}/teams/{team_slug}"],getDiscussionCommentInOrg:["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"],getDiscussionInOrg:["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"],getMembershipForUserInOrg:["GET /orgs/{org}/teams/{team_slug}/memberships/{username}"],list:["GET /orgs/{org}/teams"],listChildInOrg:["GET /orgs/{org}/teams/{team_slug}/teams"],listDiscussionCommentsInOrg:["GET /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments"],listDiscussionsInOrg:["GET /orgs/{org}/teams/{team_slug}/discussions"],listForAuthenticatedUser:["GET /user/teams"],listMembersInOrg:["GET /orgs/{org}/teams/{team_slug}/members"],listPendingInvitationsInOrg:["GET /orgs/{org}/teams/{team_slug}/invitations"],listProjectsInOrg:["GET /orgs/{org}/teams/{team_slug}/projects"],listReposInOrg:["GET /orgs/{org}/teams/{team_slug}/repos"],removeMembershipForUserInOrg:["DELETE /orgs/{org}/teams/{team_slug}/memberships/{username}"],removeProjectInOrg:["DELETE /orgs/{org}/teams/{team_slug}/projects/{project_id}"],removeRepoInOrg:["DELETE /orgs/{org}/teams/{team_slug}/repos/{owner}/{repo}"],updateDiscussionCommentInOrg:["PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments/{comment_number}"],updateDiscussionInOrg:["PATCH /orgs/{org}/teams/{team_slug}/discussions/{discussion_number}"],updateInOrg:["PATCH /orgs/{org}/teams/{team_slug}"]},users:{addEmailForAuthenticated:["POST /user/emails",{},{renamed:["users","addEmailForAuthenticatedUser"]}],addEmailForAuthenticatedUser:["POST /user/emails"],addSocialAccountForAuthenticatedUser:["POST /user/social_accounts"],block:["PUT /user/blocks/{username}"],checkBlocked:["GET /user/blocks/{username}"],checkFollowingForUser:["GET /users/{username}/following/{target_user}"],checkPersonIsFollowedByAuthenticated:["GET /user/following/{username}"],createGpgKeyForAuthenticated:["POST /user/gpg_keys",{},{renamed:["users","createGpgKeyForAuthenticatedUser"]}],createGpgKeyForAuthenticatedUser:["POST /user/gpg_keys"],createPublicSshKeyForAuthenticated:["POST /user/keys",{},{renamed:["users","createPublicSshKeyForAuthenticatedUser"]}],createPublicSshKeyForAuthenticatedUser:["POST /user/keys"],createSshSigningKeyForAuthenticatedUser:["POST /user/ssh_signing_keys"],deleteEmailForAuthenticated:["DELETE /user/emails",{},{renamed:["users","deleteEmailForAuthenticatedUser"]}],deleteEmailForAuthenticatedUser:["DELETE /user/emails"],deleteGpgKeyForAuthenticated:["DELETE /user/gpg_keys/{gpg_key_id}",{},{renamed:["users","deleteGpgKeyForAuthenticatedUser"]}],deleteGpgKeyForAuthenticatedUser:["DELETE /user/gpg_keys/{gpg_key_id}"],deletePublicSshKeyForAuthenticated:["DELETE /user/keys/{key_id}",{},{renamed:["users","deletePublicSshKeyForAuthenticatedUser"]}],deletePublicSshKeyForAuthenticatedUser:["DELETE /user/keys/{key_id}"],deleteSocialAccountForAuthenticatedUser:["DELETE /user/social_accounts"],deleteSshSigningKeyForAuthenticatedUser:["DELETE /user/ssh_signing_keys/{ssh_signing_key_id}"],follow:["PUT /user/following/{username}"],getAuthenticated:["GET /user"],getByUsername:["GET /users/{username}"],getContextForUser:["GET /users/{username}/hovercard"],getGpgKeyForAuthenticated:["GET /user/gpg_keys/{gpg_key_id}",{},{renamed:["users","getGpgKeyForAuthenticatedUser"]}],getGpgKeyForAuthenticatedUser:["GET /user/gpg_keys/{gpg_key_id}"],getPublicSshKeyForAuthenticated:["GET /user/keys/{key_id}",{},{renamed:["users","getPublicSshKeyForAuthenticatedUser"]}],getPublicSshKeyForAuthenticatedUser:["GET /user/keys/{key_id}"],getSshSigningKeyForAuthenticatedUser:["GET /user/ssh_signing_keys/{ssh_signing_key_id}"],list:["GET /users"],listBlockedByAuthenticated:["GET /user/blocks",{},{renamed:["users","listBlockedByAuthenticatedUser"]}],listBlockedByAuthenticatedUser:["GET /user/blocks"],listEmailsForAuthenticated:["GET /user/emails",{},{renamed:["users","listEmailsForAuthenticatedUser"]}],listEmailsForAuthenticatedUser:["GET /user/emails"],listFollowedByAuthenticated:["GET /user/following",{},{renamed:["users","listFollowedByAuthenticatedUser"]}],listFollowedByAuthenticatedUser:["GET /user/following"],listFollowersForAuthenticatedUser:["GET /user/followers"],listFollowersForUser:["GET /users/{username}/followers"],listFollowingForUser:["GET /users/{username}/following"],listGpgKeysForAuthenticated:["GET /user/gpg_keys",{},{renamed:["users","listGpgKeysForAuthenticatedUser"]}],listGpgKeysForAuthenticatedUser:["GET /user/gpg_keys"],listGpgKeysForUser:["GET /users/{username}/gpg_keys"],listPublicEmailsForAuthenticated:["GET /user/public_emails",{},{renamed:["users","listPublicEmailsForAuthenticatedUser"]}],listPublicEmailsForAuthenticatedUser:["GET /user/public_emails"],listPublicKeysForUser:["GET /users/{username}/keys"],listPublicSshKeysForAuthenticated:["GET /user/keys",{},{renamed:["users","listPublicSshKeysForAuthenticatedUser"]}],listPublicSshKeysForAuthenticatedUser:["GET /user/keys"],listSocialAccountsForAuthenticatedUser:["GET /user/social_accounts"],listSocialAccountsForUser:["GET /users/{username}/social_accounts"],listSshSigningKeysForAuthenticatedUser:["GET /user/ssh_signing_keys"],listSshSigningKeysForUser:["GET /users/{username}/ssh_signing_keys"],setPrimaryEmailVisibilityForAuthenticated:["PATCH /user/email/visibility",{},{renamed:["users","setPrimaryEmailVisibilityForAuthenticatedUser"]}],setPrimaryEmailVisibilityForAuthenticatedUser:["PATCH /user/email/visibility"],unblock:["DELETE /user/blocks/{username}"],unfollow:["DELETE /user/following/{username}"],updateAuthenticated:["PATCH /user"]}},endpointMethodsMap=new Map;for(const[scope,endpoints]of Object.entries(endpoints_default))for(const[methodName,endpoint]of Object.entries(endpoints)){const[route,defaults,decorations]=endpoint,[method,url]=route.split(/ /),endpointDefaults=Object.assign({method,url},defaults);endpointMethodsMap.has(scope)||endpointMethodsMap.set(scope,new Map),endpointMethodsMap.get(scope).set(methodName,{scope,methodName,endpointDefaults,decorations})}var handler={has:({scope},methodName)=>endpointMethodsMap.get(scope).has(methodName),getOwnPropertyDescriptor(target,methodName){return{value:this.get(target,methodName),configurable:!0,writable:!0,enumerable:!0}},defineProperty:(target,methodName,descriptor)=>(Object.defineProperty(target.cache,methodName,descriptor),!0),deleteProperty:(target,methodName)=>(delete target.cache[methodName],!0),ownKeys:({scope})=>[...endpointMethodsMap.get(scope).keys()],set:(target,methodName,value)=>target.cache[methodName]=value,get({octokit,scope,cache},methodName){if(cache[methodName])return cache[methodName];const method=endpointMethodsMap.get(scope).get(methodName);if(!method)return;const{endpointDefaults,decorations}=method;return cache[methodName]=decorations?function decorate(octokit,scope,methodName,defaults,decorations){const requestWithDefaults=octokit.request.defaults(defaults);function withDecorations(...args){let options=requestWithDefaults.endpoint.merge(...args);if(decorations.mapToData)return options=Object.assign({},options,{data:options[decorations.mapToData],[decorations.mapToData]:void 0}),requestWithDefaults(options);if(decorations.renamed){const[newScope,newMethodName]=decorations.renamed;octokit.log.warn(`octokit.${scope}.${methodName}() has been renamed to octokit.${newScope}.${newMethodName}()`)}if(decorations.deprecated&&octokit.log.warn(decorations.deprecated),decorations.renamedParameters){const options2=requestWithDefaults.endpoint.merge(...args);for(const[name,alias]of Object.entries(decorations.renamedParameters))name in options2&&(octokit.log.warn(`"${name}" parameter is deprecated for "octokit.${scope}.${methodName}()". Use "${alias}" instead`),alias in options2||(options2[alias]=options2[name]),delete options2[name]);return requestWithDefaults(options2)}return requestWithDefaults(...args)}return Object.assign(withDecorations,requestWithDefaults)}(octokit,scope,methodName,endpointDefaults,decorations):octokit.request.defaults(endpointDefaults),cache[methodName]}};function endpointsToMethods(octokit){const newMethods={};for(const scope of endpointMethodsMap.keys())newMethods[scope]=new Proxy({octokit,scope,cache:{}},handler);return newMethods}function restEndpointMethods(octokit){return{rest:endpointsToMethods(octokit)}}restEndpointMethods.VERSION="10.2.0";var light=__webpack_require__("./node_modules/bottleneck/light.js"),light_default=__webpack_require__.n(light),request_error_dist_web=__webpack_require__("./node_modules/@octokit/request-error/dist-web/index.js");async function errorRequest(state,octokit,error,options){if(!error.request||!error.request.request)throw error;if(error.status>=400&&!state.doNotRetry.includes(error.status)){const retries=null!=options.request.retries?options.request.retries:state.retries,retryAfter=Math.pow((options.request.retryCount||0)+1,2);throw octokit.retry.retryRequest(error,retries,retryAfter)}throw error}async function wrapRequest(state,octokit,request,options){const limiter=new(light_default());return limiter.on("failed",(function(error,info){const maxRetries=~~error.request.request.retries,after=~~error.request.request.retryAfter;if(options.request.retryCount=info.retryCount+1,maxRetries>info.retryCount)return after*state.retryAfterBaseValue})),limiter.schedule(requestWithGraphqlErrorHandling.bind(null,state,octokit,request),options)}async function requestWithGraphqlErrorHandling(state,octokit,request,options){const response=await request(request,options);if(response.data&&response.data.errors&&/Something went wrong while executing your query/.test(response.data.errors[0].message)){return errorRequest(state,octokit,new request_error_dist_web.RequestError(response.data.errors[0].message,500,{request:options,response}),options)}return response}function retry(octokit,octokitOptions){const state=Object.assign({enabled:!0,retryAfterBaseValue:1e3,doNotRetry:[400,401,403,404,422,451],retries:3},octokitOptions.retry);return state.enabled&&(octokit.hook.error("request",errorRequest.bind(null,state,octokit)),octokit.hook.wrap("request",wrapRequest.bind(null,state,octokit))),{retry:{retryRequest:(error,retries,retryAfter)=>(error.request.request=Object.assign({},error.request.request,{retries,retryAfter}),error)}}}retry.VERSION="6.0.1";var noop=()=>Promise.resolve();function dist_web_wrapRequest(state,request,options){return state.retryLimiter.schedule(doRequest,state,request,options)}async function doRequest(state,request,options){const isWrite="GET"!==options.method&&"HEAD"!==options.method,{pathname}=new URL(options.url,"http://github.test"),isSearch="GET"===options.method&&pathname.startsWith("/search/"),isGraphQL=pathname.startsWith("/graphql"),jobOptions=~~request.retryCount>0?{priority:0,weight:0}:{};state.clustering&&(jobOptions.expiration=6e4),(isWrite||isGraphQL)&&await state.write.key(state.id).schedule(jobOptions,noop),isWrite&&state.triggersNotification(pathname)&&await state.notifications.key(state.id).schedule(jobOptions,noop),isSearch&&await state.search.key(state.id).schedule(jobOptions,noop);const req=state.global.key(state.id).schedule(jobOptions,request,options);if(isGraphQL){const res=await req;if(null!=res.data.errors&&res.data.errors.some((error=>"RATE_LIMITED"===error.type))){throw Object.assign(new Error("GraphQL Rate Limit Exceeded"),{response:res,data:res.data})}}return req}var regex=function routeMatcher(paths){const regex2=`^(?:${paths.map((path=>path.split("/").map((c=>c.startsWith("{")?"(?:.+?)":c)).join("/"))).map((r=>`(?:${r})`)).join("|")})[^/]*$`;return new RegExp(regex2,"i")}(["/orgs/{org}/invitations","/orgs/{org}/invitations/{invitation_id}","/orgs/{org}/teams/{team_slug}/discussions","/orgs/{org}/teams/{team_slug}/discussions/{discussion_number}/comments","/repos/{owner}/{repo}/collaborators/{username}","/repos/{owner}/{repo}/commits/{commit_sha}/comments","/repos/{owner}/{repo}/issues","/repos/{owner}/{repo}/issues/{issue_number}/comments","/repos/{owner}/{repo}/pulls","/repos/{owner}/{repo}/pulls/{pull_number}/comments","/repos/{owner}/{repo}/pulls/{pull_number}/comments/{comment_id}/replies","/repos/{owner}/{repo}/pulls/{pull_number}/merge","/repos/{owner}/{repo}/pulls/{pull_number}/requested_reviewers","/repos/{owner}/{repo}/pulls/{pull_number}/reviews","/repos/{owner}/{repo}/releases","/teams/{team_id}/discussions","/teams/{team_id}/discussions/{discussion_number}/comments"]),triggersNotification=regex.test.bind(regex),groups={};function throttling(octokit,octokitOptions){const{enabled=!0,Bottleneck=light_default(),id="no-id",timeout=12e4,connection}=octokitOptions.throttle||{};if(!enabled)return{};const common={connection,timeout};null==groups.global&&function(Bottleneck,common){groups.global=new Bottleneck.Group({id:"octokit-global",maxConcurrent:10,...common}),groups.search=new Bottleneck.Group({id:"octokit-search",maxConcurrent:1,minTime:2e3,...common}),groups.write=new Bottleneck.Group({id:"octokit-write",maxConcurrent:1,minTime:1e3,...common}),groups.notifications=new Bottleneck.Group({id:"octokit-notifications",maxConcurrent:1,minTime:3e3,...common})}(Bottleneck,common);const state=Object.assign({clustering:null!=connection,triggersNotification,fallbackSecondaryRateRetryAfter:60,retryAfterBaseValue:1e3,retryLimiter:new Bottleneck,id,...groups},octokitOptions.throttle);if("function"!=typeof state.onSecondaryRateLimit||"function"!=typeof state.onRateLimit)throw new Error("octokit/plugin-throttling error:\n        You must pass the onSecondaryRateLimit and onRateLimit error handlers.\n        See https://octokit.github.io/rest.js/#throttling\n\n        const octokit = new Octokit({\n          throttle: {\n            onSecondaryRateLimit: (retryAfter, options) => {/* ... */},\n            onRateLimit: (retryAfter, options) => {/* ... */}\n          }\n        })\n    ");const events={},emitter=new Bottleneck.Events(events);return events.on("secondary-limit",state.onSecondaryRateLimit),events.on("rate-limit",state.onRateLimit),events.on("error",(e=>octokit.log.warn("Error in throttling-plugin limit handler",e))),state.retryLimiter.on("failed",(async function(error,info){const[state2,request,options]=info.args,{pathname}=new URL(options.url,"http://github.test");if(!(pathname.startsWith("/graphql")&&401!==error.status)&&403!==error.status)return;const retryCount=~~request.retryCount;request.retryCount=retryCount,options.request.retryCount=retryCount;const{wantRetry,retryAfter=0}=await async function(){if(/\bsecondary rate\b/i.test(error.message)){const retryAfter2=Number(error.response.headers["retry-after"])||state2.fallbackSecondaryRateRetryAfter;return{wantRetry:await emitter.trigger("secondary-limit",retryAfter2,options,octokit,retryCount),retryAfter:retryAfter2}}if(null!=error.response.headers&&"0"===error.response.headers["x-ratelimit-remaining"]||(error.response.data?.errors??[]).some((error2=>"RATE_LIMITED"===error2.type))){const rateLimitReset=new Date(1e3*~~error.response.headers["x-ratelimit-reset"]).getTime(),retryAfter2=Math.max(Math.ceil((rateLimitReset-Date.now())/1e3)+1,0);return{wantRetry:await emitter.trigger("rate-limit",retryAfter2,options,octokit,retryCount),retryAfter:retryAfter2}}return{}}();return wantRetry?(request.retryCount++,retryAfter*state2.retryAfterBaseValue):void 0})),octokit.hook.wrap("request",dist_web_wrapRequest.bind(null,state)),{}}throttling.VERSION="8.1.3",throttling.triggersNotification=triggersNotification;var dist_node=__webpack_require__("./node_modules/@octokit/auth-app/dist-node/index.js"),oauth_app_dist_node=__webpack_require__("./node_modules/@octokit/oauth-app/dist-node/index.js"),auth_unauthenticated_dist_web=__webpack_require__("./node_modules/@octokit/auth-unauthenticated/dist-web/index.js"),aggregate_error=__webpack_require__("./node_modules/aggregate-error/index.js"),aggregate_error_default=__webpack_require__.n(aggregate_error),Algorithm=(Algorithm2=>(Algorithm2.SHA1="sha1",Algorithm2.SHA256="sha256",Algorithm2))(Algorithm||{}),getAlgorithm=signature=>signature.startsWith("sha256=")?"sha256":"sha1",enc=new TextEncoder;function getHMACHashName(algorithm){return{[Algorithm.SHA1]:"SHA-1",[Algorithm.SHA256]:"SHA-256"}[algorithm]}async function importKey(secret,algorithm){return crypto.subtle.importKey("raw",enc.encode(secret),{name:"HMAC",hash:{name:getHMACHashName(algorithm)}},!1,["sign","verify"])}async function sign(options,payload){const{secret,algorithm}="object"==typeof options?{secret:options.secret,algorithm:options.algorithm||Algorithm.SHA256}:{secret:options,algorithm:Algorithm.SHA256};if(!secret||!payload)throw new TypeError("[@octokit/webhooks-methods] secret & payload required for sign()");if(!Object.values(Algorithm).includes(algorithm))throw new TypeError(`[@octokit/webhooks] Algorithm ${algorithm} is not supported. Must be  'sha1' or 'sha256'`);return`${algorithm}=${function UInt8ArrayToHex(signature){return Array.prototype.map.call(new Uint8Array(signature),(x=>x.toString(16).padStart(2,"0"))).join("")}(await crypto.subtle.sign("HMAC",await importKey(secret,algorithm),enc.encode(payload)))}`}async function verify(secret,eventPayload,signature){if(!secret||!eventPayload||!signature)throw new TypeError("[@octokit/webhooks-methods] secret, eventPayload & signature required");const algorithm=getAlgorithm(signature);return await crypto.subtle.verify("HMAC",await importKey(secret,algorithm),function hexToUInt8Array(string){const integers=string.match(/[\dA-F]{2}/gi).map((function(s){return parseInt(s,16)}));return new Uint8Array(integers)}(signature.replace(`${algorithm}=`,"")),enc.encode(eventPayload))}var console=__webpack_require__("./node_modules/console-browserify/index.js"),createLogger=(__webpack_require__("./node_modules/node-polyfill-webpack-plugin/node_modules/buffer/index.js").Buffer,logger=>({debug:()=>{},info:()=>{},warn:console.warn.bind(console),error:console.error.bind(console),...logger})),emitterEventNames=["branch_protection_rule","branch_protection_rule.created","branch_protection_rule.deleted","branch_protection_rule.edited","check_run","check_run.completed","check_run.created","check_run.requested_action","check_run.rerequested","check_suite","check_suite.completed","check_suite.requested","check_suite.rerequested","code_scanning_alert","code_scanning_alert.appeared_in_branch","code_scanning_alert.closed_by_user","code_scanning_alert.created","code_scanning_alert.fixed","code_scanning_alert.reopened","code_scanning_alert.reopened_by_user","commit_comment","commit_comment.created","create","delete","dependabot_alert","dependabot_alert.created","dependabot_alert.dismissed","dependabot_alert.fixed","dependabot_alert.reintroduced","dependabot_alert.reopened","deploy_key","deploy_key.created","deploy_key.deleted","deployment","deployment.created","deployment_protection_rule","deployment_protection_rule.requested","deployment_status","deployment_status.created","discussion","discussion.answered","discussion.category_changed","discussion.created","discussion.deleted","discussion.edited","discussion.labeled","discussion.locked","discussion.pinned","discussion.transferred","discussion.unanswered","discussion.unlabeled","discussion.unlocked","discussion.unpinned","discussion_comment","discussion_comment.created","discussion_comment.deleted","discussion_comment.edited","fork","github_app_authorization","github_app_authorization.revoked","gollum","installation","installation.created","installation.deleted","installation.new_permissions_accepted","installation.suspend","installation.unsuspend","installation_repositories","installation_repositories.added","installation_repositories.removed","installation_target","installation_target.renamed","issue_comment","issue_comment.created","issue_comment.deleted","issue_comment.edited","issues","issues.assigned","issues.closed","issues.deleted","issues.demilestoned","issues.edited","issues.labeled","issues.locked","issues.milestoned","issues.opened","issues.pinned","issues.reopened","issues.transferred","issues.unassigned","issues.unlabeled","issues.unlocked","issues.unpinned","label","label.created","label.deleted","label.edited","marketplace_purchase","marketplace_purchase.cancelled","marketplace_purchase.changed","marketplace_purchase.pending_change","marketplace_purchase.pending_change_cancelled","marketplace_purchase.purchased","member","member.added","member.edited","member.removed","membership","membership.added","membership.removed","merge_group","merge_group.checks_requested","meta","meta.deleted","milestone","milestone.closed","milestone.created","milestone.deleted","milestone.edited","milestone.opened","org_block","org_block.blocked","org_block.unblocked","organization","organization.deleted","organization.member_added","organization.member_invited","organization.member_removed","organization.renamed","package","package.published","package.updated","page_build","ping","project","project.closed","project.created","project.deleted","project.edited","project.reopened","project_card","project_card.converted","project_card.created","project_card.deleted","project_card.edited","project_card.moved","project_column","project_column.created","project_column.deleted","project_column.edited","project_column.moved","projects_v2_item","projects_v2_item.archived","projects_v2_item.converted","projects_v2_item.created","projects_v2_item.deleted","projects_v2_item.edited","projects_v2_item.reordered","projects_v2_item.restored","public","pull_request","pull_request.assigned","pull_request.auto_merge_disabled","pull_request.auto_merge_enabled","pull_request.closed","pull_request.converted_to_draft","pull_request.demilestoned","pull_request.dequeued","pull_request.edited","pull_request.enqueued","pull_request.labeled","pull_request.locked","pull_request.milestoned","pull_request.opened","pull_request.ready_for_review","pull_request.reopened","pull_request.review_request_removed","pull_request.review_requested","pull_request.synchronize","pull_request.unassigned","pull_request.unlabeled","pull_request.unlocked","pull_request_review","pull_request_review.dismissed","pull_request_review.edited","pull_request_review.submitted","pull_request_review_comment","pull_request_review_comment.created","pull_request_review_comment.deleted","pull_request_review_comment.edited","pull_request_review_thread","pull_request_review_thread.resolved","pull_request_review_thread.unresolved","push","registry_package","registry_package.published","registry_package.updated","release","release.created","release.deleted","release.edited","release.prereleased","release.published","release.released","release.unpublished","repository","repository.archived","repository.created","repository.deleted","repository.edited","repository.privatized","repository.publicized","repository.renamed","repository.transferred","repository.unarchived","repository_dispatch","repository_import","repository_vulnerability_alert","repository_vulnerability_alert.create","repository_vulnerability_alert.dismiss","repository_vulnerability_alert.reopen","repository_vulnerability_alert.resolve","secret_scanning_alert","secret_scanning_alert.created","secret_scanning_alert.reopened","secret_scanning_alert.resolved","secret_scanning_alert.revoked","secret_scanning_alert_location","secret_scanning_alert_location.created","security_advisory","security_advisory.performed","security_advisory.published","security_advisory.updated","security_advisory.withdrawn","sponsorship","sponsorship.cancelled","sponsorship.created","sponsorship.edited","sponsorship.pending_cancellation","sponsorship.pending_tier_change","sponsorship.tier_changed","star","star.created","star.deleted","status","team","team.added_to_repository","team.created","team.deleted","team.edited","team.removed_from_repository","team_add","watch","watch.started","workflow_dispatch","workflow_job","workflow_job.completed","workflow_job.in_progress","workflow_job.queued","workflow_job.waiting","workflow_run","workflow_run.completed","workflow_run.in_progress","workflow_run.requested"];function handleEventHandlers(state,webhookName,handler){state.hooks[webhookName]||(state.hooks[webhookName]=[]),state.hooks[webhookName].push(handler)}function receiverOn(state,webhookNameOrNames,handler){if(Array.isArray(webhookNameOrNames))webhookNameOrNames.forEach((webhookName=>receiverOn(state,webhookName,handler)));else{if(["*","error"].includes(webhookNameOrNames)){const webhookName="*"===webhookNameOrNames?"any":webhookNameOrNames,message=`Using the "${webhookNameOrNames}" event with the regular Webhooks.on() function is not supported. Please use the Webhooks.on${webhookName.charAt(0).toUpperCase()+webhookName.slice(1)}() method instead`;throw new Error(message)}emitterEventNames.includes(webhookNameOrNames)||state.log.warn(`"${webhookNameOrNames}" is not a known webhook name (https://developer.github.com/v3/activity/events/types/)`),handleEventHandlers(state,webhookNameOrNames,handler)}}function receiverOnAny(state,handler){handleEventHandlers(state,"*",handler)}function receiverOnError(state,handler){handleEventHandlers(state,"error",handler)}function wrapErrorHandler(handler,error){let returnValue;try{returnValue=handler(error)}catch(error2){console.log('FATAL: Error occurred in "error" event handler'),console.log(error2)}returnValue&&returnValue.catch&&returnValue.catch((error2=>{console.log('FATAL: Error occurred in "error" event handler'),console.log(error2)}))}function receiverHandle(state,event){const errorHandlers=state.hooks.error||[];if(event instanceof Error){const error=Object.assign(new(aggregate_error_default())([event]),{event,errors:[event]});return errorHandlers.forEach((handler=>wrapErrorHandler(handler,error))),Promise.reject(error)}if(!event||!event.name)throw new(aggregate_error_default())(["Event name not passed"]);if(!event.payload)throw new(aggregate_error_default())(["Event payload not passed"]);const hooks=function getHooks(state,eventPayloadAction,eventName){const hooks=[state.hooks[eventName],state.hooks["*"]];return eventPayloadAction&&hooks.unshift(state.hooks[`${eventName}.${eventPayloadAction}`]),[].concat(...hooks.filter(Boolean))}(state,"action"in event.payload?event.payload.action:null,event.name);if(0===hooks.length)return Promise.resolve();const errors=[],promises=hooks.map((handler=>{let promise=Promise.resolve(event);return state.transform&&(promise=promise.then(state.transform)),promise.then((event2=>handler(event2))).catch((error=>errors.push(Object.assign(error,{event}))))}));return Promise.all(promises).then((()=>{if(0===errors.length)return;const error=new(aggregate_error_default())(errors);throw Object.assign(error,{event,errors}),errorHandlers.forEach((handler=>wrapErrorHandler(handler,error))),error}))}function removeListener(state,webhookNameOrNames,handler){if(Array.isArray(webhookNameOrNames))webhookNameOrNames.forEach((webhookName=>removeListener(state,webhookName,handler)));else if(state.hooks[webhookNameOrNames])for(let i=state.hooks[webhookNameOrNames].length-1;i>=0;i--)if(state.hooks[webhookNameOrNames][i]===handler)return void state.hooks[webhookNameOrNames].splice(i,1)}function createEventHandler(options){const state={hooks:{},log:createLogger(options&&options.log)};return options&&options.transform&&(state.transform=options.transform),{on:receiverOn.bind(null,state),onAny:receiverOnAny.bind(null,state),onError:receiverOnError.bind(null,state),removeListener:removeListener.bind(null,state),receive:receiverHandle.bind(null,state)}}async function verifyAndReceive(state,event){if(!await verify(state.secret,event.payload,event.signature).catch((()=>!1))){const error=new Error("[@octokit/webhooks] signature does not match event payload and secret");return state.eventHandler.receive(Object.assign(error,{event,status:400}))}let payload;try{payload=JSON.parse(event.payload)}catch(error){throw error.message="Invalid JSON",error.status=400,new(aggregate_error_default())([error])}return state.eventHandler.receive({id:event.id,name:event.name,payload})}var Webhooks=class{constructor(options){if(!options||!options.secret)throw new Error("[@octokit/webhooks] options.secret required");const state={eventHandler:createEventHandler(options),secret:options.secret,hooks:{},log:createLogger(options.log)};this.sign=sign.bind(null,options.secret),this.verify=verify.bind(null,options.secret),this.on=state.eventHandler.on,this.onAny=state.eventHandler.onAny,this.onError=state.eventHandler.onError,this.removeListener=state.eventHandler.removeListener,this.receive=state.eventHandler.receive,this.verifyAndReceive=verifyAndReceive.bind(null,state)}},dist_web_console=__webpack_require__("./node_modules/console-browserify/index.js");async function getInstallationOctokit(app,installationId){return app.octokit.auth({type:"installation",installationId,factory(auth){const options={...auth.octokitOptions,authStrategy:dist_node.createAppAuth,auth:{...auth,installationId}};return new auth.octokit.constructor(options)}})}function eachInstallationFactory(app){return Object.assign(eachInstallation.bind(null,app),{iterator:eachInstallationIterator.bind(null,app)})}async function eachInstallation(app,callback){const i=eachInstallationIterator(app)[Symbol.asyncIterator]();let result=await i.next();for(;!result.done;)await callback(result.value),result=await i.next()}function eachInstallationIterator(app){return{async*[Symbol.asyncIterator](){const iterator=composePaginateRest.iterator(app.octokit,"GET /app/installations");for await(const{data:installations}of iterator)for(const installation of installations){const installationOctokit=await getInstallationOctokit(app,installation.id);yield{octokit:installationOctokit,installation}}}}}function eachRepositoryFactory(app){return Object.assign(eachRepository.bind(null,app),{iterator:eachRepositoryIterator.bind(null,app)})}async function eachRepository(app,queryOrCallback,callback){const i=eachRepositoryIterator(app,callback?queryOrCallback:void 0)[Symbol.asyncIterator]();let result=await i.next();for(;!result.done;)callback?await callback(result.value):await queryOrCallback(result.value),result=await i.next()}function eachRepositoryIterator(app,query){return{async*[Symbol.asyncIterator](){const iterator=query?function singleInstallationIterator(app,installationId){return{async*[Symbol.asyncIterator](){yield{octokit:await app.getInstallationOctokit(installationId)}}}}(app,query.installationId):app.eachInstallation.iterator();for await(const{octokit}of iterator){const repositoriesIterator=composePaginateRest.iterator(octokit,"GET /installation/repositories");for await(const{data:repositories}of repositoriesIterator)for(const repository of repositories)yield{octokit,repository}}}}}var App=class{static{this.VERSION="14.0.2"}static defaults(defaults){return class extends(this){constructor(...args){super({...defaults,...args[0]})}}}constructor(options){const Octokit5=options.Octokit||dist_web.Octokit,authOptions=Object.assign({appId:options.appId,privateKey:options.privateKey},options.oauth?{clientId:options.oauth.clientId,clientSecret:options.oauth.clientSecret}:{});this.octokit=new Octokit5({authStrategy:dist_node.createAppAuth,auth:authOptions,log:options.log}),this.log=Object.assign({debug:()=>{},info:()=>{},warn:dist_web_console.warn.bind(dist_web_console),error:dist_web_console.error.bind(dist_web_console)},options.log),options.webhooks?this.webhooks=function webhooks(appOctokit,options){return new Webhooks({secret:options.secret,transform:async event=>{if(!("installation"in event.payload)||"object"!=typeof event.payload.installation){const octokit2=new appOctokit.constructor({authStrategy:auth_unauthenticated_dist_web.createUnauthenticatedAuth,auth:{reason:'"installation" key missing in webhook event payload'}});return{...event,octokit:octokit2}}const installationId=event.payload.installation.id,octokit=await appOctokit.auth({type:"installation",installationId,factory:auth=>new auth.octokit.constructor({...auth.octokitOptions,authStrategy:dist_node.createAppAuth,auth:{...auth,installationId}})});return octokit.hook.before("request",(options2=>{options2.headers["x-github-delivery"]=event.id})),{...event,octokit}}})}(this.octokit,options.webhooks):Object.defineProperty(this,"webhooks",{get(){throw new Error("[@octokit/app] webhooks option not set")}}),options.oauth?this.oauth=new oauth_app_dist_node.OAuthApp({...options.oauth,clientType:"github-app",Octokit:Octokit5}):Object.defineProperty(this,"oauth",{get(){throw new Error("[@octokit/app] oauth.clientId / oauth.clientSecret options are not set")}}),this.getInstallationOctokit=getInstallationOctokit.bind(null,this),this.eachInstallation=eachInstallationFactory(this),this.eachRepository=eachRepositoryFactory(this)}},Octokit=dist_web.Octokit.plugin(restEndpointMethods,paginateRest,(function paginateGraphql(octokit){return octokit.graphql,{graphql:Object.assign(octokit.graphql,{paginate:Object.assign(createPaginate(octokit),{iterator:createIterator(octokit)})})}}),retry,throttling).defaults({userAgent:"octokit.js/3.1.2",throttle:{onRateLimit:function onRateLimit(retryAfter,options,octokit){if(octokit.log.warn(`Request quota exhausted for request ${options.method} ${options.url}`),0===options.request.retryCount)return octokit.log.info(`Retrying after ${retryAfter} seconds!`),!0},onSecondaryRateLimit:function onSecondaryRateLimit(retryAfter,options,octokit){if(octokit.log.warn(`SecondaryRateLimit detected for request ${options.method} ${options.url}`),0===options.request.retryCount)return octokit.log.info(`Retrying after ${retryAfter} seconds!`),!0}}});App.defaults({Octokit}),oauth_app_dist_node.OAuthApp.defaults({Octokit})},"./node_modules/once/once.js":(module,__unused_webpack_exports,__webpack_require__)=>{var wrappy=__webpack_require__("./node_modules/wrappy/wrappy.js");function once(fn){var f=function(){return f.called?f.value:(f.called=!0,f.value=fn.apply(this,arguments))};return f.called=!1,f}function onceStrict(fn){var f=function(){if(f.called)throw new Error(f.onceError);return f.called=!0,f.value=fn.apply(this,arguments)},name=fn.name||"Function wrapped with `once`";return f.onceError=name+" shouldn't be called more than once",f.called=!1,f}module.exports=wrappy(once),module.exports.strict=wrappy(onceStrict),once.proto=once((function(){Object.defineProperty(Function.prototype,"once",{value:function(){return once(this)},configurable:!0}),Object.defineProperty(Function.prototype,"onceStrict",{value:function(){return onceStrict(this)},configurable:!0})}))},"./node_modules/rooks/dist/esm/hooks/useDebounce.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.d(__webpack_exports__,{N:()=>useDebounce});var lodash_debounce=__webpack_require__("./node_modules/lodash.debounce/index.js"),lodash_debounce_default=__webpack_require__.n(lodash_debounce),react=__webpack_require__("./node_modules/next/dist/compiled/react/index.js");const useIsomorphicEffect="undefined"==typeof window?react.useEffect:react.useLayoutEffect;function useDebounce(callback,wait,options){const createDebouncedCallback=(0,react.useCallback)((function_=>lodash_debounce_default()(function_,wait,options)),[wait,options]),freshCallback=function useFreshRef(value,preferLayoutEffect=!1){const useEffectToUse=preferLayoutEffect?useIsomorphicEffect:react.useEffect,ref=(0,react.useRef)(value);return useEffectToUse((()=>{ref.current=value})),ref}(callback);const debouncedCallbackRef=(0,react.useRef)(createDebouncedCallback((function tick(...args){var _a;null===(_a=freshCallback.current)||void 0===_a||_a.call(freshCallback,...args)})));return function useWillUnmount(callback){(0,react.useEffect)((()=>callback),[])}((()=>{var _a;return null===(_a=debouncedCallbackRef.current)||void 0===_a?void 0:_a.cancel()})),debouncedCallbackRef.current}},"./node_modules/universal-github-app-jwt/dist-web/index.bundled.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";function t(t,n,r,e,i,a,o){try{var u=t[a](o),c=u.value}catch(t){return void r(t)}u.done?n(c):Promise.resolve(c).then(e,i)}function n(n){return function(){var r=this,e=arguments;return new Promise((function(i,a){var o=n.apply(r,e);function u(n){t(o,i,a,u,c,"next",n)}function c(n){t(o,i,a,u,c,"throw",n)}u(void 0)}))}}function r(t){for(var n=new ArrayBuffer(t.length),r=new Uint8Array(n),e=0,i=t.length;e<i;e++)r[e]=t.charCodeAt(e);return n}function e(t){return t.replace(/=/g,"").replace(/\+/g,"-").replace(/\//g,"_")}function i(t){return e(btoa(JSON.stringify(t)))}__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{githubAppJwt:()=>o});var a=function(){var t=n((function*(t){var{privateKey:n,payload:a}=t;if(/BEGIN RSA PRIVATE KEY/.test(n))throw new Error("[universal-github-app-jwt] Private Key is in PKCS#1 format, but only PKCS#8 is supported. See https://github.com/gr2m/universal-github-app-jwt#readme");var o,u={name:"RSASSA-PKCS1-v1_5",hash:{name:"SHA-256"}},c=(o=n.trim().split("\n").slice(1,-1).join(""),r(atob(o))),p=yield crypto.subtle.importKey("pkcs8",c,u,!1,["sign"]),f=function(t,n){return"".concat(i({alg:"RS256",typ:"JWT"}),".").concat(i(n))}(0,a),l=r(f),s=function(t){for(var n="",r=new Uint8Array(t),i=r.byteLength,a=0;a<i;a++)n+=String.fromCharCode(r[a]);return e(btoa(n))}(yield crypto.subtle.sign(u.name,p,l));return"".concat(f,".").concat(s)}));return function(n){return t.apply(this,arguments)}}();function o(t){return u.apply(this,arguments)}function u(){return(u=n((function*(t){var{id:n,privateKey:r,now:e=Math.floor(Date.now()/1e3)}=t,i=e-30,o=i+600,u={iat:i,exp:o,iss:n};return{appId:n,expiration:o,token:yield a({privateKey:r,payload:u})}}))).apply(this,arguments)}},"./node_modules/universal-user-agent/dist-web/index.js":(__unused_webpack_module,__webpack_exports__,__webpack_require__)=>{"use strict";__webpack_require__.r(__webpack_exports__),__webpack_require__.d(__webpack_exports__,{getUserAgent:()=>getUserAgent});var process=__webpack_require__("./node_modules/process/browser.js");function getUserAgent(){return"object"==typeof navigator&&"userAgent"in navigator?navigator.userAgent:"object"==typeof process&&void 0!==process.version?`Node.js/${process.version.substr(1)} (${process.platform}; ${process.arch})`:"<environment undetectable>"}},"./node_modules/wrappy/wrappy.js":module=>{module.exports=function wrappy(fn,cb){if(fn&&cb)return wrappy(fn)(cb);if("function"!=typeof fn)throw new TypeError("need wrapper function");return Object.keys(fn).forEach((function(k){wrapper[k]=fn[k]})),wrapper;function wrapper(){for(var args=new Array(arguments.length),i=0;i<args.length;i++)args[i]=arguments[i];var ret=fn.apply(this,args),cb=args[args.length-1];return"function"==typeof ret&&ret!==cb&&Object.keys(cb).forEach((function(k){ret[k]=cb[k]})),ret}}}}]);